{"meta":{"title":"Ocsxxi","subtitle":"","description":"","author":"Zhiyuan Alex Liu","url":"https://ocsxxi.github.io","root":"/"},"pages":[{"title":"","date":"2020-10-31T10:38:46.337Z","updated":"2018-01-26T06:41:06.000Z","comments":true,"path":"404.html","permalink":"https://ocsxxi.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2018-12-20T13:00:00.000Z","updated":"2020-10-31T10:42:02.028Z","comments":true,"path":"about/index.html","permalink":"https://ocsxxi.github.io/about/index.html","excerpt":"","text":"欢迎大家来到我的个人博客～ 如果你有什么话想对我说，请在下面的评论区留言给我吧！"},{"title":"Archives","date":"2020-10-31T10:54:33.370Z","updated":"2020-10-31T10:54:33.338Z","comments":true,"path":"archives/index.html","permalink":"https://ocsxxi.github.io/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-10-31T10:45:27.623Z","updated":"2020-10-31T10:45:27.607Z","comments":true,"path":"tags/index.html","permalink":"https://ocsxxi.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-10-31T10:54:26.558Z","updated":"2020-10-31T10:54:26.434Z","comments":false,"path":"categories/index.html","permalink":"https://ocsxxi.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"软件工程师与程序员对比","slug":"软件工程师与程序员对比","date":"2020-10-31T06:07:00.000Z","updated":"2020-10-31T06:13:36.146Z","comments":true,"path":"2020/10/31/软件工程师与程序员对比/","link":"","permalink":"https://ocsxxi.github.io/2020/10/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AF%B9%E6%AF%94/","excerpt":"","text":"tr td:first-child {font-weight:bold;} 软件工程师 程序员/码农 学历要求 本科及以上 专科及以上 工作 内容 设计并完善软件系统， 保障软件代码的高可重用性 写代码，能运行就行 职位 设计者 实施者 软件工程 注重软件工程流程 无 框架语言要求 低 高 软技能要求（代码洁癖、计算机原理、算法等） 高 低 文档能力 高 低 工作中的关注点 人机交互 功能正确 团队精神与协作能力 高 中 需求理解能力 高 低 模块化思维能力 高 中 数学与建模能力 高 低 测试能力 高 低 工作量 中 高 从事工作技术含量 高 低 英语 高 低 进度与质量把控 高 低 自我驱动力 高 低 工作交付时完成的任务 需求文档软件代码软件设计书单元测试 集成测试系统测试 UI测试交付说明书 软件使用说明书 …… 软件代码功能测试 最终目标 提升人们的生活质量 挣钱","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://ocsxxi.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://ocsxxi.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"职业生涯","slug":"职业生涯","permalink":"https://ocsxxi.github.io/tags/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"}]},{"title":"总结-随机事件与概率","slug":"总结-随机事件与概率","date":"2020-10-30T09:35:02.000Z","updated":"2020-10-30T10:29:27.038Z","comments":true,"path":"2020/10/30/总结-随机事件与概率/","link":"","permalink":"https://ocsxxi.github.io/2020/10/30/%E6%80%BB%E7%BB%93-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/","excerpt":"","text":"一、古典概型 摸球问题 一把抓（无序）： 组合 逐个取（有序）： 不放回： $n\\Omega$ 要逐渐减小 放回【独立】：$n\\Omega$不变 抽签摸奖与次序无关：若a个中奖球，b个不中奖球，前n-1次不明确，那么第n次中奖的的概率即$\\frac{a}{a+b}$ 分房问题 指定 （不用选） 恰 （需要选） 人数要求 取样问题 含与不含 或与且 最大与最小 二、几何概型长度、面积、体积的比值 三、事件的运算包含、相等、和、积、差、互不相容、对立 $P(A-B)=P(A\\bar{B})=P(A)-P(AB)$ 互不相容 ：$AB=\\phi$ 对立 ：$AB=\\phi$ 且 $A+B=\\Omega$ ( P(AB)=P($\\bar{A}\\bar{B}$) ) 互不相容 $\\overset{\\nrightarrow}{\\leftarrow}$ 对立 事件关系 $\\overset{\\nleftarrow}{\\rightarrow}$ 概率关系 概率等式关系 $P(AB)\\overset{独立}{=}P(A)P(B)$ P($A_先B_后$) $\\overset{乘}{=}$ P(A) P(B|A) P(AB) $\\overset{加}{=}$ P(A) + P(B) -P(A+B) P(AB) $\\overset{减}{=}$ P(A) - P(A$\\bar{B}$) = P(B) - P($\\bar{A}$B) P(AB) $\\overset{对立}{=}$ 1 - P($\\overline{AB}$) = 1 - P($\\bar{A} \\bigcup \\bar{B}$) 四、概率不等式关系 0 $\\leq$ P(A) $\\leq$ 1 A$\\subset$B $\\Longrightarrow$ P(A) $\\leq$ P(B) P(B|A) &gt; P(AB) AB $\\subseteq$ A $\\Longrightarrow$ P(AB) $\\leq$ P(A) AB $\\subseteq$ B $\\Longrightarrow$ P(AB) $\\leq$ P(B) $\\Longrightarrow$ P(AB) $\\leq$ $\\frac{P(A)+P(B)}{2}$ $\\Longrightarrow$ P(AB) $\\leq$ min[ P(A)， P(B) ] P(AB) $\\overset{加}{=}$ P(A) + P(B) - P(A+B) P(A+B) $\\in$ [ 0, 1 ] $\\Longrightarrow$ P(AB) $\\geq$ P(A) + P(B) -1 五、条件概率与乘法公式条件概率也是概率，其满足概率的一切性质 $$P(B|A)=\\frac{P(AB)}{P(A)}$$ P(ABC) = P(A)P(B|A)P(C|AB) 条件概率的计算： 抽象：扣定义 具体：缩小样本空间 逆概：Bayes公式 P(A|B)与P(A)的大小关系(P(A)&gt;0,P(B)&gt;0) 当A$\\subset$B时 P(A|B) = $\\frac{P(AB)}{P(B)}$ = $\\frac{P(A)}{P(B)}$ $\\geq$ P(A) 当B$\\subset$A时 P(A|B) = $\\frac{P(B)}{P(B)}$ = 1 $\\geq$ P(A) 当AB=$\\phi$时 P(A|B) = 0 $\\leq$ P(A) 当P(AB)=P(A)P(B)时 P(A|B) = $\\frac{P(AB)}{P(B)}$ = $\\frac{P(A)P(B)}{P(B)}$ = P(A) 六、独立性与伯努利独立：P(AB)=P(A)P(B) 独立等价： P(B|A) = P(B|$\\bar{A}$) P(B|A) = $\\frac{P(AB)}{P(A)}$ = P(B) P(B|A) = P($\\bar{B}$|$\\bar{A}$) = 1 若事件A与B相互独立，则“爱逆不逆”（即事件A发生条件下，对事件B的概率毫无影响） 判定两事件独立： 靠先前经验判断 独立性的意义$\\longrightarrow$有放回的抽样 扣定义 多事件间的独立性：$$A,B,C两两独立\\iff\\begin{cases}\\text{P(AB) = P(A)P(B)}\\\\\\text{P(AC) = P(A)P(C)}\\\\\\text{P(BC) = P(B)P(C)}\\end{cases}$$ $$A,B,C\\underline{相互}独立\\iff\\begin{cases}\\text{P(AB) = P(A)P(B)}\\\\\\text{P(AC) = P(A)P(C)}\\\\\\text{P(BC) = P(B)P(C)}\\\\\\underline{\\text{P(ABC) = P(A)P(B)P(C)}}\\end{cases}$$ n重伯努利事件（n重独立重复试验）（结果只有A和$\\bar{A}$，P(A)=p，P($\\bar{A}$)=1-p，也即二项分布） n次试验成功k次 ：$C_n^kp^k(1-p)^{n-k}$ 直到第n次成功了k次：$C_{n-1}^{k-1}p^k(1-p)^{n-k}$ ​ （即 n-1次试验成功了k-1次： $C_{n-1}^{k-1}p^{k-1}(1-p)^{(n-1)-(k-1)}*p$ ） 七、全概率公式与贝叶斯公式完备事件组构造方法：$\\begin{cases} \\text{两分法} \\\\ \\text{按离散随机变量取值} \\\\ \\text{广义化} \\end{cases} $ 全概率公式（由因得果）：$P(B)=\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)$ 贝叶斯公式（由果溯因）：$P(A_j|B)=\\frac{P(A_j)P(B|A_j)}{P(B)}=\\frac{P(A_j)P(B|A_j)}{\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)}$","categories":[{"name":"数学","slug":"数学","permalink":"https://ocsxxi.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://ocsxxi.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"数学","slug":"数学","permalink":"https://ocsxxi.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"考研","slug":"考研","permalink":"https://ocsxxi.github.io/tags/%E8%80%83%E7%A0%94/"}]},{"title":"JMeter断言不提示错误信息","slug":"JMeter断言不提示错误信息","date":"2019-07-31T07:56:49.000Z","updated":"2020-10-31T10:19:10.583Z","comments":true,"path":"2019/07/31/JMeter断言不提示错误信息/","link":"","permalink":"https://ocsxxi.github.io/2019/07/31/JMeter%E6%96%AD%E8%A8%80%E4%B8%8D%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/","excerpt":"","text":"因为工作需要，所以自己参考了 https://blog.csdn.net/u012111923/article/details/80705141#comments 大佬的教程，根据教程进行了一次测试。 在其中，我发现断言无论如何都不会显示，如下图即使是在View Results Tree里全部通过如下图，断言也均不显示 解决方法是因为JMeter的机制，在断言成功的状态下并不会显示断言是否成功，仅会在断言失败的情况下才会显示错误信息。接下来，在Response Assertions的界面上，随便打一段匹配文本上去，让它进行匹配，如下图所示现在点击运行，我们再来看看断言结果这不就是我们期待已久的断言结果吗，哈哈","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://ocsxxi.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"JMeter","slug":"JMeter","permalink":"https://ocsxxi.github.io/tags/JMeter/"},{"name":"性能测试","slug":"性能测试","permalink":"https://ocsxxi.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"软件测试","slug":"软件测试","permalink":"https://ocsxxi.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"测试工具","slug":"测试工具","permalink":"https://ocsxxi.github.io/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"断言","slug":"断言","permalink":"https://ocsxxi.github.io/tags/%E6%96%AD%E8%A8%80/"}]},{"title":"React Native 500报错指向 '<'","slug":"React Native 500报错指向 `<`","date":"2019-04-24T14:35:13.000Z","updated":"2020-10-31T10:14:31.815Z","comments":true,"path":"2019/04/24/React Native 500报错指向 `<`/","link":"","permalink":"https://ocsxxi.github.io/2019/04/24/React%20Native%20500%E6%8A%A5%E9%94%99%E6%8C%87%E5%90%91%20%60%3C%60/","excerpt":"","text":"前提： 配置好了React Native并且按照官网的教程，生成了我的AwesomeProject，并且成功运行。 接下来按照官网教程生成 Hello World程序，代码如下 123456789101112import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Text, View &#125; from &#x27;react-native&#x27;; export default class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 将上面的代码覆盖App.js后，在命令行中输入： 1react-native run-android 虚拟机反馈报错500，并在cmd中用红色的^指向return中第一个View的开始符号“&lt;” 解决办法： 关闭含有server的窗口，重新输入命令： 1react-native start 然后将应用部署至虚拟机，输入命令： 1react-native run-android 虚拟机在屏幕中央显示了Hello World，成功运行，问题解决。","categories":[{"name":"React Native","slug":"React-Native","permalink":"https://ocsxxi.github.io/categories/React-Native/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ocsxxi.github.io/tags/Android/"},{"name":"React Native","slug":"React-Native","permalink":"https://ocsxxi.github.io/tags/React-Native/"},{"name":"React","slug":"React","permalink":"https://ocsxxi.github.io/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ocsxxi.github.io/tags/JavaScript/"}]},{"title":"Android splash界面 —— 加载界面","slug":"Android splash界面 —— 加载界面","date":"2019-04-24T07:09:35.000Z","updated":"2020-10-31T10:09:38.578Z","comments":true,"path":"2019/04/24/Android splash界面 —— 加载界面/","link":"","permalink":"https://ocsxxi.github.io/2019/04/24/Android%20splash%E7%95%8C%E9%9D%A2%20%E2%80%94%E2%80%94%20%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2/","excerpt":"","text":"经过了两个小时的努力，终于把这个问题解决了，关于这个加载界面，真的是一把鼻涕一把泪，话不多说上代码 12345678910111213141516171819202122232425262728293031323334import android.app.Activity;import android.content.Intent;import android.os.Handler;import android.os.Message;import android.os.Bundle;import android.view.Window;import android.view.WindowManager; public class SplashActivity extends Activity &#123; private Handler handler= new Handler() &#123; @Override public void handleMessage(Message msg) &#123; jumpToMainPage(); super.handleMessage(msg); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_splash); handler.sendEmptyMessageDelayed(0,4000); &#125; public void jumpToMainPage()&#123; Intent intent = new Intent(SplashActivity.this, MainActivity.class); startActivity(intent); finish(); &#125;&#125; 在此我使用了 Handler 来进行页面的延迟自动加载 需要注意的是 requestWindowFeature() 一定要在 setContentView() 之前被执行 否则在虚拟机上运行会崩溃，emmmm至少我的是崩溃了 从知道上面这条信息还是从logcat获取的，在这之前我并不重视 logcat，所以调试的时候一定要注意logcat上的出错信息，对于程序开发会有很大的帮助 还有一点要说的就是，我的 splash界面 是由原来的 main界面 改过来的，所以一定要记得在 splash界面 中的顶层容器的 1tools:context&#x3D;&quot;&quot; 属性中填写实际的类名以及类存在的路径，否则无法启动 感谢您的阅读","categories":[{"name":"Android","slug":"Android","permalink":"https://ocsxxi.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://ocsxxi.github.io/tags/Android/"},{"name":"加载界面","slug":"加载界面","permalink":"https://ocsxxi.github.io/tags/%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2/"},{"name":"Java","slug":"Java","permalink":"https://ocsxxi.github.io/tags/Java/"}]},{"title":"Hadoop3.2.0 启动后通过jps命令找不到JobTracker和TaskTracker","slug":"Python构造函数takes no arguments","date":"2019-04-14T07:43:18.000Z","updated":"2020-10-31T10:05:28.051Z","comments":true,"path":"2019/04/14/Python构造函数takes no arguments/","link":"","permalink":"https://ocsxxi.github.io/2019/04/14/Python%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0takes%20no%20arguments/","excerpt":"","text":"如图建立People类，并实例化一个对象p1, 报错如图 我们来详细看一下如图报错：编译器告诉我们说 People类的构造函数不能接收参数 解决办法： 使用def init(self, …) ——&gt;注意这里的下划线是两个下划线__，而不是单个下划线_而非def init(self, …) 如图删除原来的People类 如图重新构建People类，并实例化People类对象p1通过sayHello()函数来测试是否成功实例化对象, 输出了信息 即构造类成功","categories":[{"name":"Python","slug":"Python","permalink":"https://ocsxxi.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ocsxxi.github.io/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"https://ocsxxi.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"程序设计","slug":"程序设计","permalink":"https://ocsxxi.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"Hadoop3.2.0 启动后通过jps命令找不到JobTracker和TaskTracker","slug":"Hadoop3.2.0 启动后通过jps命令找不到JobTracker和TaskTracker","date":"2019-04-14T07:12:30.000Z","updated":"2020-10-31T10:01:01.259Z","comments":true,"path":"2019/04/14/Hadoop3.2.0 启动后通过jps命令找不到JobTracker和TaskTracker/","link":"","permalink":"https://ocsxxi.github.io/2019/04/14/Hadoop3.2.0%20%E5%90%AF%E5%8A%A8%E5%90%8E%E9%80%9A%E8%BF%87jps%E5%91%BD%E4%BB%A4%E6%89%BE%E4%B8%8D%E5%88%B0JobTracker%E5%92%8CTaskTracker/","excerpt":"","text":"原因是Hadoop2.0以后的版本采用的是 YARN 作为资源管理器，包含了1.x版本的JobTracker和TaskTracker功能， 即 YARN 替代了单独存在的 JobTracker 与 TaskTracker。 2.0之后的版本，安装配置成功后启动Hadoop后，通过jps命令将如图只显示以下几个进程 参考：https://blog.csdn.net/ASN_forever/article/details/81062238","categories":[{"name":"大数据/云计算","slug":"大数据-云计算","permalink":"https://ocsxxi.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://ocsxxi.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://ocsxxi.github.io/tags/Hadoop/"},{"name":"JobTracker","slug":"JobTracker","permalink":"https://ocsxxi.github.io/tags/JobTracker/"},{"name":"TaskTracker","slug":"TaskTracker","permalink":"https://ocsxxi.github.io/tags/TaskTracker/"}]},{"title":"Ubuntu Server安装后无法进入root超级用户解决办法","slug":"Ubuntu Server安装后无法进入root超级用户解决办法","date":"2019-04-05T09:44:39.000Z","updated":"2020-10-31T09:58:12.590Z","comments":true,"path":"2019/04/05/Ubuntu Server安装后无法进入root超级用户解决办法/","link":"","permalink":"https://ocsxxi.github.io/2019/04/05/Ubuntu%20Server%E5%AE%89%E8%A3%85%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5root%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"因为要学习Hadoop的缘故，用VMware给自己装了个Ubuntu Server，版本是18.04.2-amd64 因为之前使用的Ubuntu Desktop版本都是安装时候设置用户的时候，用户和超级用户是同一个密码，因为是学习用，也没有太在意这些，但是这次安装成功以后居然不能用用户的密码登录超级用户，也搜了一小段时间的解决办法。 最终，给出如下解决方案： 先使用安装时创建的用户登录进系统 在控制台输入”sudo passwd” 提示输入用户密码 为root输入密码与确认密码 成功后shell会提示”passwd: password updated successfully”，就可以使用密码登录超级用户了 附上我自己成功为root用户添加密码的图片 参考: https://www.cnblogs.com/yuejin/p/3645294.html","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ocsxxi.github.io/categories/Ubuntu/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ocsxxi.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ocsxxi.github.io/tags/Ubuntu/"},{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"https://ocsxxi.github.io/tags/Ubuntu-Server/"},{"name":"服务器","slug":"服务器","permalink":"https://ocsxxi.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"版本库——Git初探","slug":"版本库——Git初探","date":"2019-03-05T13:55:49.000Z","updated":"2020-10-31T09:52:13.920Z","comments":true,"path":"2019/03/05/版本库——Git初探/","link":"","permalink":"https://ocsxxi.github.io/2019/03/05/%E7%89%88%E6%9C%AC%E5%BA%93%E2%80%94%E2%80%94Git%E5%88%9D%E6%8E%A2/","excerpt":"","text":"Git是一个简便的版本控制工具，初期使用一般是通过Git Bash来进行使用，以便于记住Git命令，后期一般通过Git GUI来进行使用，可以更加方便快捷地管理版本库。（ 版本库(repository)，也称仓库，是用于存储不同版本信息、以及文件的仓库） Git环境需要进行本地安装，官网https://git-scm.com/，通过自己的操作系统来选择合适的安装包进行下载安装并进行初始配置。 如在windows系统下，想将桌面的test文件夹作为某次开发的仓库，可以双击打开test文件夹，在空白处右键选择“git bash here”即可打开bash命令行，然后直接在bash命令行中键入 1git init 如果反馈信息如下，并在下一行等待输入，即创建版本库成功 1Initialized empty Git repository in C:/Users/Admin/Desktop/test/.git/ 在test目录内创建rd.txt文本文件，并在其中写入”hello world”继续在git bash 命令行中键入命令 1git add rd.txt 这行命令的作用是将rd.txt作为预备提交文件进行添加如果如下显示，则添加成功 接下来进行第一次提交，使用命令如下 1git commit -m &quot;&lt;提交说明&gt;&quot; &lt;提交说明&gt;可以更改为自己的说明，如果显示如下，则提交成功 我们再将rd.txt进行一次修改，再进行第二次提交然后我们现在可以键入以下命令，来查看当前仓库的日志 1git log 如下所示在黄色的commit后面长长的一串码是对应版本的版本号 我们现在假设产品经理告诉我们，第二次的修改是没有用的，那么我们就需要将版本回滚到第一版，也就是”my first commit”那一版，我们可以键入下面的命令 1git reset --hard HEAD^ 可以看到反馈了如下信息并且rd.txt和git log命令中，均只剩下第一次提交的内容，如下所示这样就说明了我们回滚操作成功了 现在再假设产品经理告诉我们，他看错了，第二次修改的内容是需要的，那么这样我们就要退回回滚操作之前，只要当前bash命令行没有关闭，并且我们还能查到第二次的版本id，那么我们就能退回回滚操作之前，命令如下 1git reset --hard &lt;版本号&gt; &lt;版本号&gt;应该填写自己命令行中的第二次提交的版本id，如下看到这里，有很多小伙伴就会迷茫了，会问：刚才显示的第二次的版本id不是116b28f9460a5a0222ef0328c0c76e3c3fc95121吗？为什么我只写了一个116b2？ 这是因为git的控制机制来说，我们只要能够给bash一个可以辨识到独一无二的版本号的序列，那么它就可以自动为我们匹配到我们想要去使用的版本号。 使用退回命令后，rd.txt内容显示如下，即表明我们的退回回滚操作之前的操作成功。 感谢您的阅读","categories":[{"name":"Git","slug":"Git","permalink":"https://ocsxxi.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ocsxxi.github.io/tags/Git/"},{"name":"Git Bash","slug":"Git-Bash","permalink":"https://ocsxxi.github.io/tags/Git-Bash/"},{"name":"版本控制","slug":"版本控制","permalink":"https://ocsxxi.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}]},{"title":"数据库中的GROUP BY与ORDER BY、WHERE与HAVING","slug":"数据库中的GROUP BY与ORDER BY、WHERE与HAVING","date":"2018-12-20T13:24:20.000Z","updated":"2020-10-31T09:34:26.861Z","comments":true,"path":"2018/12/20/数据库中的GROUP BY与ORDER BY、WHERE与HAVING/","link":"","permalink":"https://ocsxxi.github.io/2018/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84GROUP%20BY%E4%B8%8EORDER%20BY%E3%80%81WHERE%E4%B8%8EHAVING/","excerpt":"","text":"在数据库的选择操作SELECT中经常会用到聚合条件，最常见也是最常用的是WHERE语句，故本文不会着重介绍WHERE语句。 现假设在某数据库中有一个名为PRODUCT的表，表结构及内部数据如下 12345CREATE TABLE PRODUCT( Pno CHAR(20) PRIMARY KEY, Pname CHAR(10), Pamount INT); 123456789+-----+-------+---------+| Pno | Pname | Pamount |+-----+-------+---------+| 001 | a | 1 || 002 | a | 2 || 003 | b | 1 || 004 | b | 2 || 005 | b | 6 |+-----+-------+---------+ ORDER BY这一语句主要是显示排序用，如果选择了多条类似的记录，那么在查询语句中便可用到此语句，使用如下 1SELECT * FROM PRODUCT ORDER BY Pno ASC; 上面的语句根据Pno的值来对产品记录进行升序排列(仅当次查询有效)，即根据ORDER BY后跟的列名进行升序排列。 1234567891011mysql&gt; SELECT * FROM PRODUCT ORDER BY Pno ASC;+-----+-------+---------+| Pno | Pname | Pamount |+-----+-------+---------+| 001 | a | 1 || 002 | a | 2 || 003 | b | 1 || 004 | b | 2 || 005 | b | 6 |+-----+-------+---------+5 rows in set (0.00 sec) 如果需要降序排列，只需把最后的ASC更换为DESC即可。 1234567891011mysql&gt; SELECT * FROM PRODUCT ORDER BY Pno DESC;+-----+-------+---------+| Pno | Pname | Pamount |+-----+-------+---------+| 005 | b | 6 || 004 | b | 2 || 003 | b | 1 || 002 | a | 2 || 001 | a | 1 |+-----+-------+---------+5 rows in set (0.00 sec) § 当排序列含空值时,排序列为空值的原组最后显示。 GROUP BY这一语句主要是作分类汇总，如需要相同名称记录的合计库存量，在查询语句中可用到GROUP BY如下 1SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname; 结果如下 12345678mysql&gt; SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname;+-------+--------------+| Pname | SUM(Pamount) |+-------+--------------+| a | 3 || b | 9 |+-------+--------------+2 rows in set (0.00 sec) HAVINGHAVING可以作为WHERE的拓展，因为在WHERE中不可用到聚合函数，而在HAVING中可以使用聚合函数。 如需了解总量大于5的相同名称记录的合计库存量，则可用到HAVING使用如下 1SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname HAVING SUM(Pamount)&gt;5; 结果如下 1234567mysql&gt; SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname HAVING SUM(Pamount)&gt;5;+-------+--------------+| Pname | SUM(Pamount) |+-------+--------------+| b | 9 |+-------+--------------+1 row in set (0.00 sec) HAVING与WHERE作用的对象不同。WHERE 子句作用于表和视图，HAVING 子句作用于组。WHERE 在分组和聚合运算之前选取输入行（因此，它控制进入聚合运算的记录）， 而 HAVING 在分组和聚合之后选取分组的行。因此，WHERE 子句不能包含聚合函数；因为试图用聚合函数判断那些行输入做聚合运算是没有意义的。 相反，HAVING 子句总是包含聚合函数。 以上纯属个人对于选择操作中的ORDER BY、GROUP BY以及HAVING的看法及见解，如有误，感谢各位的指证","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ocsxxi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ocsxxi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://ocsxxi.github.io/tags/SQL/"},{"name":"GROUP BY","slug":"GROUP-BY","permalink":"https://ocsxxi.github.io/tags/GROUP-BY/"},{"name":"ORDER BY","slug":"ORDER-BY","permalink":"https://ocsxxi.github.io/tags/ORDER-BY/"},{"name":"HAVING","slug":"HAVING","permalink":"https://ocsxxi.github.io/tags/HAVING/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-20T13:00:00.000Z","updated":"2020-10-31T10:40:37.554Z","comments":false,"path":"2018/12/20/hello-world/","link":"","permalink":"https://ocsxxi.github.io/2018/12/20/hello-world/","excerpt":"","text":"欢迎大家来到我的个人博客","categories":[],"tags":[]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://ocsxxi.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"数学","slug":"数学","permalink":"https://ocsxxi.github.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"软件测试","slug":"软件测试","permalink":"https://ocsxxi.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"React Native","slug":"React-Native","permalink":"https://ocsxxi.github.io/categories/React-Native/"},{"name":"Android","slug":"Android","permalink":"https://ocsxxi.github.io/categories/Android/"},{"name":"Python","slug":"Python","permalink":"https://ocsxxi.github.io/categories/Python/"},{"name":"大数据/云计算","slug":"大数据-云计算","permalink":"https://ocsxxi.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ocsxxi.github.io/categories/Ubuntu/"},{"name":"Git","slug":"Git","permalink":"https://ocsxxi.github.io/categories/Git/"},{"name":"数据库","slug":"数据库","permalink":"https://ocsxxi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://ocsxxi.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"职业生涯","slug":"职业生涯","permalink":"https://ocsxxi.github.io/tags/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://ocsxxi.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"数学","slug":"数学","permalink":"https://ocsxxi.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"考研","slug":"考研","permalink":"https://ocsxxi.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"JMeter","slug":"JMeter","permalink":"https://ocsxxi.github.io/tags/JMeter/"},{"name":"性能测试","slug":"性能测试","permalink":"https://ocsxxi.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"软件测试","slug":"软件测试","permalink":"https://ocsxxi.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"测试工具","slug":"测试工具","permalink":"https://ocsxxi.github.io/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"断言","slug":"断言","permalink":"https://ocsxxi.github.io/tags/%E6%96%AD%E8%A8%80/"},{"name":"Android","slug":"Android","permalink":"https://ocsxxi.github.io/tags/Android/"},{"name":"React Native","slug":"React-Native","permalink":"https://ocsxxi.github.io/tags/React-Native/"},{"name":"React","slug":"React","permalink":"https://ocsxxi.github.io/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ocsxxi.github.io/tags/JavaScript/"},{"name":"加载界面","slug":"加载界面","permalink":"https://ocsxxi.github.io/tags/%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2/"},{"name":"Java","slug":"Java","permalink":"https://ocsxxi.github.io/tags/Java/"},{"name":"Python","slug":"Python","permalink":"https://ocsxxi.github.io/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"https://ocsxxi.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"程序设计","slug":"程序设计","permalink":"https://ocsxxi.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"大数据","slug":"大数据","permalink":"https://ocsxxi.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://ocsxxi.github.io/tags/Hadoop/"},{"name":"JobTracker","slug":"JobTracker","permalink":"https://ocsxxi.github.io/tags/JobTracker/"},{"name":"TaskTracker","slug":"TaskTracker","permalink":"https://ocsxxi.github.io/tags/TaskTracker/"},{"name":"Linux","slug":"Linux","permalink":"https://ocsxxi.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ocsxxi.github.io/tags/Ubuntu/"},{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"https://ocsxxi.github.io/tags/Ubuntu-Server/"},{"name":"服务器","slug":"服务器","permalink":"https://ocsxxi.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Git","slug":"Git","permalink":"https://ocsxxi.github.io/tags/Git/"},{"name":"Git Bash","slug":"Git-Bash","permalink":"https://ocsxxi.github.io/tags/Git-Bash/"},{"name":"版本控制","slug":"版本控制","permalink":"https://ocsxxi.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://ocsxxi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://ocsxxi.github.io/tags/SQL/"},{"name":"GROUP BY","slug":"GROUP-BY","permalink":"https://ocsxxi.github.io/tags/GROUP-BY/"},{"name":"ORDER BY","slug":"ORDER-BY","permalink":"https://ocsxxi.github.io/tags/ORDER-BY/"},{"name":"HAVING","slug":"HAVING","permalink":"https://ocsxxi.github.io/tags/HAVING/"}]}