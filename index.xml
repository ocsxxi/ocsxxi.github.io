<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ocsxxi&#39;s Blog</title>
    <link>https://ocsxxi.top/</link>
    <description>Recent content on Ocsxxi&#39;s Blog</description>
    <image>
      <title>Ocsxxi&#39;s Blog</title>
      <url>https://ocsxxi.top/images/papermod-cover.png</url>
      <link>https://ocsxxi.top/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 15 Jan 2024 11:40:00 +0800</lastBuildDate>
    <atom:link href="https://ocsxxi.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>为爱付出与自我感动</title>
      <link>https://ocsxxi.top/posts/2024-01-15-1/</link>
      <pubDate>Mon, 15 Jan 2024 11:40:00 +0800</pubDate>
      <guid>https://ocsxxi.top/posts/2024-01-15-1/</guid>
      <description>本文定义了为爱付出与自我感动，对二者的区别给出具体表述。描述了两种特殊的付出活动。并给出了自我感动纠偏的建议。</description>
    </item>
    <item>
      <title>Python使用os.listdir时与windows资源管理器展示顺序不一致</title>
      <link>https://ocsxxi.top/posts/2024-01-13-1/</link>
      <pubDate>Sat, 13 Jan 2024 01:28:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2024-01-13-1/</guid>
      <description>背景 Python 中 os 模块所提供的 listdir() 方法给出的序列，会由于执行器的编码情况而不同.在未设置的 cli 中使用 gbk 排序，在配置过的 IDE 中使用 UTF-8。
无论是gbk还是UTF-8编码，均不是按照拼音排序，从而导致了与Windows资源管理器中的顺序不一致。
解决 使用 pip 下载 natsort 包。
其中有一个函数 os_sorted() 即与操作系统给出的文件顺序保持一致。
使用 1 2 3 4 5 6 7 8 import os from natsort import os_sorted pwd = os.getcwd() # 获取当前目录 filenamelist = os.listdir(pwd) # ls该目录 sortedlist = os_sorted(filenamelist) # 即为排好序的文件列表 print(sortedlist) </description>
    </item>
    <item>
      <title>无边框Electron拖动时窗口大小发生改变解决方法</title>
      <link>https://ocsxxi.top/posts/2023-05-13-1/</link>
      <pubDate>Fri, 12 May 2023 10:42:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2023-05-13-1/</guid>
      <description>背景 根据网络搜索引擎提供的解决方法，如 electron无边框模式完美解决同时实现拖动和双击最大化等，发现了：添加代码后，拖动窗口时窗口移动，但同时窗口大小发生意想不到的改变。
解决 考虑到计算机图形是为了在屏幕上显示点阵图像，计算中会产生精度误差，从而导致图形抖动。
尝试移动窗口前记录窗口尺寸，移动后重设窗口尺寸
1 2 3 let oldsize = mainWindow.getSize() ... mainWindow.setSize(oldsize.width, oldsize.height) 运行尝试，并未达到预期效果。窗口大小仍然会发生大幅改变。
网络上搜索不到相关内容，只能无尽的查api，发现另一个函数 xxxBounds()：
1 2 3 4 5 let oldBounds = mainWindow.getBounds() ... oldBounds.x = x oldBounds.y = y mainWindow.setBounds(oldBounds, true) 注意这个函数与xxxSize()之间的差异，getBounds()会返回一个四个属性的对象，属性值分别为x-&amp;gt;x坐标，y-&amp;gt;y坐标，width-&amp;gt;窗口宽度，height-&amp;gt;窗口高度。
所以在示例中将移动目标点的(x,y)坐标赋值修改至oldBounds，这样通过setBounds函数同时维护窗口的位置及维度。
运行尝试，成功，窗口大小不会再发生大幅改变。试着读取窗口大小，变化幅度仅为1像素，长期拖动也不会出现问题。 出现该问题，并且搜不到相关问题解决方案，原因可能是我计算机的显示设置-缩放与布局设置的是125%（仅作猜想，未经验证！）</description>
    </item>
    <item>
      <title>微信小程序重新进入页面后自动播放视频不重播</title>
      <link>https://ocsxxi.top/posts/2022-06-07-1/</link>
      <pubDate>Tue, 07 Jun 2022 22:00:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2022-06-07-1/</guid>
      <description>背景 有需求如下
打开某页面后在背景中自动播放视频，在页面不变，切出小程序后，再切回小程序，页面重新自动播放视频
在编写之后，发现微信自身的配置并不能支持在小程序不销毁的情况下，在重新打开页面的时候重新播放视频
解决 考虑到是否可以利用页面周期事件onHide与onShow，配合调用视频播放api进行播放
编写onHide与onShow事件函数如下，假设videoContext是在onReady函数中已经获取好的视频组件句柄
1 2 3 4 5 6 7 8 9 10 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ this.videoContext.play() this.pagehide = false } }, 运行尝试，并未达到预期效果
恍惚间想起之前项目中碰到的微信小程序的坑，可能在当时重新打开微信小程序的一瞬间，句柄不能正常使用，尝试修改代码如下
1 2 3 4 5 6 7 8 9 10 11 12 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ this.$nextTick(()=&amp;gt;{ this.videoContext.play() }) this.pagehide = false } }, 运行尝试，这次发现有几率能够在重新打开页面时，恍惚间想起之前项目中碰到的微信小程序的解决方式，尝试修改代码如下 1 2 3 4 5 6 7 8 9 10 onHide() { this.</description>
    </item>
    <item>
      <title>微信小程序点击变更样式难设置</title>
      <link>https://ocsxxi.top/posts/2022-04-04-2/</link>
      <pubDate>Mon, 04 Apr 2022 01:19:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2022-04-04-2/</guid>
      <description>背景 相信很多老前端做微信小程序点击样式的时候，都喜欢直接搁样式里:hover,:focus,:active三连，还有些时候真机调试压根没反应，
时间长了，代码维护起来又累又辛苦。
解决 多给组件设置一个hover-class，微信官方专门留给点击样式的。相关css代码全局写一个都够用了，妈妈再也不用担心我的样式表五米长了
1 2 3 &amp;lt;view class=&amp;#34;...&amp;#34; hover-class=&amp;#34;...&amp;#34;&amp;gt; &amp;lt;!-- 子组件 --&amp;gt; &amp;lt;/view&amp;gt; 其实还可以配合hover-stop-propagation属性使用，该属性接受布尔值，默认为false。如果设置为true则会阻止事件冒泡给父组件，可以有效提升代码执行速度。
读文档要认真！
嗯，吃一堑长一智，以后要尽量不以先入为主的观念看问题。</description>
    </item>
    <item>
      <title>微信小程序设置动画API后图片闪动并且延迟高的解决方法</title>
      <link>https://ocsxxi.top/posts/2022-04-04-1/</link>
      <pubDate>Mon, 04 Apr 2022 01:11:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2022-04-04-1/</guid>
      <description>问题背景 如下方代码所示，该段代码在微信开发者工具内动画正常且流畅，但运行在ios设备中运行时发生动画卡顿，难以触发动画，且时常发生卡顿。
1 2 3 &amp;lt;view animation={{animation}}&amp;gt; &amp;lt;img src=&amp;#34;...&amp;#34; mode=&amp;#34;widthFix&amp;#34; style=&amp;#34;width: 100%&amp;#34;/&amp;gt; &amp;lt;/view&amp;gt; 尝试解决的思路 把相同动画应用到文本按键上，在ios设备中运行时，按键动画展示丝滑且无闪烁，考虑是内容的问题。
尝试将image组件更换为cover-image组件。我所设置的view外层有一个圆角，并且有一个缩放动画，在更改完组件后，圆角消失，动画变为了偏移而非缩放，也就是说小程序的animation变形并未作用到cover组件上，放弃这条路。
（在微信官方文档中无论是在cover系列组件的章节，还是animation的章节，均未提到其是剥离文档流而存在这件事，算是个坑，也可呢是官方没想到会有人这么玩吧）
尝试使用background-image样式来替换image组件，成功。 最终解决方案 把image图片设置未外层view的background-image就能完美解决了，亲测有效，在ios设备上展示丝滑，且不会发生图片闪烁。</description>
    </item>
    <item>
      <title>踩着油门建立的http连接——nginx开启http2</title>
      <link>https://ocsxxi.top/posts/2022-04-02-2/</link>
      <pubDate>Sat, 02 Apr 2022 17:06:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2022-04-02-2/</guid>
      <description>页面访问慢，架了cdn也没用？试试http2吧。
以前的http连接，单次连接都是访问单个资源，http2就是在http连接的基础上，直接复用第一次建立http连接时的网络通路，不用每一次都要&amp;quot;三次挥手&amp;quot;啦。
解决 原server的监听端口配置如下
1 2 - listen 443 ssl; + listen 443 ssl http2; 即可开启http2的使用之旅啦。
注 记得保证使用的nginx编译包含了with-http_v2_module模块，并且要保证同时启用ssl与http2。
如果是通过
1 apt install nginx 方式安装的nginx，那么通常来说已经默认编译包含了http2这个模块。
如果不能确定是否包含了这个模块，则可以使用
1 nginx -V 这个命令来查看自己使用的nginx是否编译包含了这个模块。</description>
    </item>
    <item>
      <title>html组件化的必由之路——nginx开启ssi</title>
      <link>https://ocsxxi.top/posts/2022-04-02-1/</link>
      <pubDate>Sat, 02 Apr 2022 10:50:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2022-04-02-1/</guid>
      <description>配置背景 大多数项目中，都会有没办法使用前端工程化方法维护的html页面，或者使用jade/pug(下文统称pug)技术来维护这些html页面。
其实pug技术也不是全能的，毕竟还要经过一次编译，对本地环境需要有node.js的要求。
对于不方便安装node.js的机器，开启nginx/httpd的ssi配置项能够极大的提高代码的可重用性。
配置方法，以nginx为例 nginx是使用配置文件来描述提供服务的项目，对于那些需要开启ssi配置项的项目，可以在对应的server描述中添加下列配置项：
ssi on; ssi_silent_errors off; ssi_types text/html; 重启nginx或重载nginx配置项后，ssi功能便启用啦，详细的配置项字段值参考nginx文档https://nginx.org/en/docs/http/ngx_http_ssi_module.html
ssi的使用方法 他的使用方法，建议参考php的文件引入，两者功能很相似。
&amp;lt;!-- #include file=&amp;#34;文件名称&amp;#34; --&amp;gt; &amp;lt;!-- #include virtual=&amp;#34;文件名称&amp;#34; --&amp;gt; file描述的是服务器上的绝对路径 virtual描述的是相对于服务器根目录的相对路径
正确的使用ssi会极大的降低html的可维护性，读者可以自行尝试多种可能性，比如网站主题换肤(所有html共用模板文件，共同引入主题样式文件；或者引入子文件夹中的主题样式文件)。
虽然ssi不能像webcomponent或pug那样灵活，但是相较于纯html项目来说已经是前进了一大步。</description>
    </item>
    <item>
      <title>如何做一名好的管理者</title>
      <link>https://ocsxxi.top/posts/2022-03-25-1/</link>
      <pubDate>Fri, 25 Mar 2022 14:58:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2022-03-25-1/</guid>
      <description>贴近下属，但也要远离下属。贴近下属的生活，原理下属的生活职业规划。如果想贴近下属的职业规划，争取为下属涨薪就是最好且最优的选择。
学会察言观色。不是附和，而是知趣。别人不想听的时候，就不要浪费各自的时间了。
培育下属固然重要，但不是拔苗助长，不是强行灌输自己的思想就一定能达到自己的目的，通常情况下都会适得其反。
每个人都是隐藏的金子，要善于发现下属的优点并能让他得到成长，让他得到成长不是把本不该下属做的事分给下属做。发现优点是一个闪光的过程，不是让下属害怕优点被发现的过程。
人是过程的集合，固然有一段经历会让人影响深刻，但这段经历不是止步不前的理由。
当今的管理学有相当一部分的应用是错误的，不要照搬照抄，比如人效，只要保证每个人的工作能够顺利按时完成即可，只要份内工作做完了，哪怕坐在工位上打游戏看电影又有何妨。要求下属延长工时，又不发放福里，相互折磨不说，还会疏远管理者与下属之间的关系。
管理者什么都会并不是一件好事，甚至很有可能动摇管理者的权威。什么都会，但什么都不精通，不管拿什么出来都会成为笑话。
学会说话，要能委婉但又犀利地描述自己的观点。在照顾双方情感的基础上，不拖泥带水，不浪费时间。
自降身段是拉近上下级关系的有效方法，但不是把手伸进别人的私人空间里。
别人拍马屁是喜欢，但自升身段是纯属自恋。
管理是要管在实处的，不是流于表象的，如果是演出来的管理，不如选择不浪费时间，至少不会疏远与下属间的关系。
饼可以画，但是既然画了，就最好要做到，如果做不到，不如重新定一个小一点的可行目标。虽然可能给不了一个长久的未来，至少要证明现阶段的正确性。
谨言慎行，每一句“随便”说出来的话都会把下属“随便”记住。口碑对于管理者也很重要。要学会多放下，多夸赞。
“这个人有思想”应该是别人给自己的评价，不能是自评出来的。
新想法的提出是要经过可行性论证的，不是每个新想法都百分百可行，不是每个新宪法都一定要落地，要选择性的使用这些想法。经过一段时间的沉淀之后冒出来的新想法是清爽可口的盐汽水；源源不断冒出来的新想法是在炉子上烧开105读的蒸馏水。</description>
    </item>
    <item>
      <title>线性代数公式定理 (李永乐版)</title>
      <link>https://ocsxxi.top/posts/2020-12-20-1/</link>
      <pubDate>Sun, 20 Dec 2020 15:25:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2020-12-20-1/</guid>
      <description>公式 行列式 $|A| = a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}(按行展开)$
$\quad \ = a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}(按行展开)$
特别的
（1）上、下三角行列式：主对角元素的乘积
$$ \left|\begin{matrix} &amp;amp; a_{12} &amp;amp; &amp;amp; \cdots &amp;amp; a_{1n} \\ &amp;amp; &amp;amp; a_{22} &amp;amp; \cdots &amp;amp;a_{2n} \\ &amp;amp; &amp;amp; &amp;amp; \ddots &amp;amp; \vdots \\ &amp;amp; &amp;amp; &amp;amp; &amp;amp;a_{nn}\end{matrix}\right|=\left|\begin{matrix}a_{11} &amp;amp; &amp;amp; &amp;amp; \\a_{21} &amp;amp; a_{22} &amp;amp; &amp;amp; \\\vdots &amp;amp; &amp;amp; \ddots &amp;amp; \\a_{n1} &amp;amp; a_{n2} &amp;amp; \cdots &amp;amp;a_{nn}\end{matrix}\right|=\left|\begin{matrix}a_{11} &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; a_{22} &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp;a_{nn}a_{11}\end{matrix}\right| $$</description>
    </item>
    <item>
      <title>现代软件工程“敏捷模型”的个人看法</title>
      <link>https://ocsxxi.top/posts/2020-11-15-2/</link>
      <pubDate>Sun, 15 Nov 2020 14:13:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2020-11-15-2/</guid>
      <description>问题描述 现在，在我国来看，无论大中小三种企业，均喜欢使用软件工程过程中的“敏捷模型”。
使用了“敏捷模型”的企业，大多的软件流程如下：
产品经理产出原型
架构师/主管开始拆分模块并分配至开发人员
产品经理开始补文档
这种方法虽然开发速度快，但是实际上，整个开发团队对于需求的理解是模糊的。
这种流程，在需求确认的时候，无法拿出一份符合软件行业规范的文档，仅仅以原型作为展示，来与客户、开发、测试等人员进行沟通。
实际上，纵观软件工程的发展史，我们就会发现，一切回到了最初的起点：软件危机。
仅使用原型来与客户进行需求确认，导致客户确认的需求比较模糊
架构/主管按照原型进行模块划分，导致软件整体架构是按照当前需求最优的，后期需求一旦变更，就会导致大面积的代码变更
模块虽不会对开发人员产生模糊，但是由于需求实际上并不是“确认”的，开发人员将可能产出错误的软件实现。
将对测试人员的工作产生巨大的影响，比如，测试人员认为有问题，但是开发人员认为没问题，产品经理也坚持没问题/下一版再说。
缺少文档、需求模糊、更改耗时耗力、一再拖拉，传说中的软件危机就这样再一次出现了。
如何避免和改善： 一日没有《需求分析说明书》，开发人员和测试人员就一日不应工作。</description>
    </item>
    <item>
      <title>有关软件的讨论</title>
      <link>https://ocsxxi.top/posts/2020-11-15-1/</link>
      <pubDate>Sun, 15 Nov 2020 14:11:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2020-11-15-1/</guid>
      <description>软件的定义 根据《软件工程》的规定，
软件 = 文档 + 数据 + 程序
我们能了解到，程序只是软件的一部分。
我们也可以获得软件的定义：
软件是采用了适当的算法与数据结构，并拥有完备的软件描述信息的一套指令的集合。
软件工程的关注点 我们都知道，（一套高质量的）程序是软件工程的最终目标，但是，程序并不是软件工程的关注点，文档与过程才是。
软件过程的开始 当项目立项后，可行性分析认为**“可行”**时，就正式的进入了软件工程过程。
（在这里，我不将可行性分析阶段算入软件工程过程，因为若可行性分析的结果是“不可行”，那么软件将不会存在）
软件过程的核心文档 《需求分析说明书》将成为了软件的第一个部分。它是软件工程过程中，最重要，也是最容易出现问题的部分。
当进入了需求分析阶段时，以最普遍的W模型来看，意味着测试工程师可以开始工作了，也即整个软件团队的成员都需要开始工作了。《需求分析说明书》就像一块凝结核，软件会在这个“凝结核”的基础上逐渐生长，慢慢成为坚固的“晶体结构”。
程序与软件的对比 我们再反观程序。程序就不一样了，在程序中，一定要有可运行的计算机代码，如果没有可运行的计算机代码，那么程序只能叫做算法，或是PDL。相比较于软件的“晶体结构”，程序就是一盘”散沙”，虽然掺点水可以做成沙堡，但是非常脆弱。
广义化的软件 那么站在软件工程过程上来说，我们就可以这样广义化描述：
当文档开始进入了软件工程过程时，即可被称之为软件。
在这种描述下，软件可以（在软件过程中）脱离程序而独立存在，也可以结合程序达到最终目标，但软件绝对不等价于程序。</description>
    </item>
    <item>
      <title>软件工程师与程序员对比</title>
      <link>https://ocsxxi.top/posts/2020-10-31-1/</link>
      <pubDate>Sat, 31 Oct 2020 06:07:00 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2020-10-31-1/</guid>
      <description>软件工程师 程序员/码农 学历要求 本科及以上 专科及以上 工作 内容 设计并完善软件系统， 保障软件代码的高可重用性 写代码，能运行就行 职位 设计者 实施者 软件工程 注重软件工程流程 无 框架语言要求 低 高 软技能要求（代码洁癖、 计算机原理、算法等） 高 低 文档能力 高 低 工作中的关注点 人机交互 功能正确 团队精神与协作能力 高 中 需求理解能力 高 低 模块化思维能力 高 中 数学与建模能力 高 低 测试能力 高 低 工作量 中 高 从事工作技术含量 高 低 英语 高 低 进度与质量把控 高 低 自我驱动力 高 低 工作交付时完成的任务 需求文档
软件代码
软件设计书
单元测试
集成测试
系统测试
UI测试
交付说明书
软件使用说明书</description>
    </item>
    <item>
      <title>总结-随机事件与概率</title>
      <link>https://ocsxxi.top/posts/2020-10-30-1/</link>
      <pubDate>Fri, 30 Oct 2020 09:35:02 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2020-10-30-1/</guid>
      <description>一、古典概型 摸球问题
一把抓（无序）： 组合
逐个取（有序）：
不放回： $n\Omega$ 要逐渐减小 放回【独立】：$n\Omega$不变 抽签摸奖与次序无关：若a个中奖球，b个不中奖球，前n-1次不明确，那么第n次中奖的的概率即$\frac{a}{a+b}$
分房问题
指定 （不用选） 恰 （需要选） 人数要求 取样问题
含与不含 或与且 最大与最小 二、几何概型 长度、面积、体积的比值
三、事件的运算 包含、相等、和、积、差、互不相容、对立
$P(A-B)=P(A\bar{B})=P(A)-P(AB)$
互不相容 ：$AB=\phi$
对立 ：$AB=\phi$ 且 $A+B=\Omega$ ( P(AB)=P($\bar{A}\bar{B}$) )
互不相容 $\overset{\nrightarrow}{\leftarrow}$ 对立
事件关系 $\overset{\nleftarrow}{\rightarrow}$ 概率关系
概率等式关系
$P(AB)\overset{独立}{=}P(A)P(B)$ P($A_先B_后$) $\overset{乘}{=}$ P(A) P(B|A) P(AB) $\overset{加}{=}$ P(A) + P(B) -P(A+B) P(AB) $\overset{减}{=}$ P(A) - P(A$\bar{B}$) = P(B) - P($\bar{A}$B) P(AB) $\overset{对立}{=}$ 1 - P($\overline{AB}$) = 1 - P($\bar{A} \bigcup \bar{B}$) 四、概率不等式关系 0 $\leq$ P(A) $\leq$ 1 A$\subset$B $\Longrightarrow$ P(A) $\leq$ P(B) P(B|A) &amp;gt; P(AB) AB $\subseteq$ A $\Longrightarrow$ P(AB) $\leq$ P(A)</description>
    </item>
    <item>
      <title>JMeter断言不提示错误信息</title>
      <link>https://ocsxxi.top/posts/2019-07-31-1/</link>
      <pubDate>Wed, 31 Jul 2019 07:56:49 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-07-31-1/</guid>
      <description>问题描述 因为工作需要，所以自己参考了 https://blog.csdn.net/u012111923/article/details/80705141#comments 大佬的教程，根据教程进行了一次测试。
在其中，我发现断言无论如何都不会显示，如下图
即使是在View Results Tree里全部通过如下图，断言也均不显示
解决方法 是因为JMeter的机制，在断言成功的状态下并不会显示断言是否成功，仅会在断言失败的情况下才会显示错误信息。
接下来，在Response Assertions的界面上，随便打一段匹配文本上去，让它进行匹配，如下图所示
现在点击运行，我们再来看看断言结果
这不就是我们期待已久的断言结果吗，哈哈</description>
    </item>
    <item>
      <title>Android splash界面 —— 加载界面</title>
      <link>https://ocsxxi.top/posts/2019-04-24-1/</link>
      <pubDate>Wed, 24 Apr 2019 15:43:18 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-04-24-1/</guid>
      <description>经过了两个小时的努力，终于把这个问题解决了，关于这个加载界面，真的是一把鼻涕一把泪，话不多说上代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import android.app.Activity; import android.content.Intent; import android.os.Handler; import android.os.Message; import android.os.Bundle; import android.view.Window; import android.view.WindowManager; public class SplashActivity extends Activity { private Handler handler= new Handler() { @Override public void handleMessage(Message msg) { jumpToMainPage(); super.handleMessage(msg); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.</description>
    </item>
    <item>
      <title>React Native 500报错指向 &#39;&lt;&#39;</title>
      <link>https://ocsxxi.top/posts/2019-04-24-2/</link>
      <pubDate>Wed, 24 Apr 2019 14:35:13 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-04-24-2/</guid>
      <description>前提： 配置好了React Native并且按照官网的教程，生成了我的AwesomeProject，并且成功运行。
复现 接下来按照官网教程生成 Hello World程序，代码如下
1 2 3 4 5 6 7 8 9 10 11 12 import React, { Component } from &amp;#39;react&amp;#39;; import { Text, View } from &amp;#39;react-native&amp;#39;; export default class HelloWorldApp extends Component { render() { return ( &amp;lt;View style={{ flex: 1, justifyContent: &amp;#34;center&amp;#34;, alignItems: &amp;#34;center&amp;#34; }}&amp;gt; &amp;lt;Text&amp;gt;Hello, world!&amp;lt;/Text&amp;gt; &amp;lt;/View&amp;gt; ); } } 将上面的代码覆盖App.js后，在命令行中输入：
1 react-native run-android 虚拟机反馈报错500，并在cmd中用红色的^指向return中第一个View的开始符号“&amp;lt;”
解决 关闭含有server的窗口，重新输入命令：
1 react-native start 然后将应用部署至虚拟机，输入命令：</description>
    </item>
    <item>
      <title>Python构造函数takes no arguments</title>
      <link>https://ocsxxi.top/posts/2019-04-14-2/</link>
      <pubDate>Sun, 14 Apr 2019 15:43:18 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-04-14-2/</guid>
      <description>如图建立People类，并实例化一个对象p1, 报错如图
我们来详细看一下如图报错：编译器告诉我们说 People类的构造函数不能接收参数
解决办法：
使用def init(self, …) ——&amp;gt;注意这里的下划线是两个下划线__，而不是单个下划线_
而非def init(self, …)
如图删除原来的People类
如图重新构建People类，并实例化People类对象p1
通过sayHello()函数来测试是否成功实例化对象, 输出了信息
即构造类成功</description>
    </item>
    <item>
      <title>Hadoop3.2.0 启动后通过jps命令找不到JobTracker和TaskTracker</title>
      <link>https://ocsxxi.top/posts/2019-04-14-1/</link>
      <pubDate>Sun, 14 Apr 2019 07:12:30 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-04-14-1/</guid>
      <description>原因是Hadoop2.0以后的版本采用的是 YARN 作为资源管理器，包含了1.x版本的JobTracker和TaskTracker功能，
即 YARN 替代了单独存在的 JobTracker 与 TaskTracker。
2.0之后的版本，安装配置成功后启动Hadoop后，通过jps命令将如图只显示以下几个进程
参考：https://blog.csdn.net/ASN_forever/article/details/81062238</description>
    </item>
    <item>
      <title>Ubuntu Server安装后无法进入root超级用户解决办法</title>
      <link>https://ocsxxi.top/posts/2019-04-05-1/</link>
      <pubDate>Fri, 05 Apr 2019 09:44:39 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-04-05-1/</guid>
      <description>因为要学习Hadoop的缘故，用VMware给自己装了个Ubuntu Server，版本是18.04.2-amd64
因为之前使用的Ubuntu Desktop版本都是安装时候设置用户的时候，用户和超级用户是同一个密码，因为是学习用，也没有太在意这些，但是这次安装成功以后居然不能用用户的密码登录超级用户，也搜了一小段时间的解决办法。
最终，给出如下解决方案：
先使用安装时创建的用户登录进系统
在控制台输入”sudo passwd”
提示输入用户密码
为root输入密码与确认密码
成功后shell会提示”passwd: password updated successfully”，就可以使用密码登录超级用户了
附上我自己成功为root用户添加密码的图片
参考: https://www.cnblogs.com/yuejin/p/3645294.html</description>
    </item>
    <item>
      <title>版本库——Git初探</title>
      <link>https://ocsxxi.top/posts/2019-03-05-1/</link>
      <pubDate>Tue, 05 Mar 2019 13:55:49 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2019-03-05-1/</guid>
      <description>Git是一个简便的版本控制工具，初期使用一般是通过Git Bash来进行使用，以便于记住Git命令，后期一般通过Git GUI来进行使用，可以更加方便快捷地管理版本库。（ 版本库(repository)，也称仓库，是用于存储不同版本信息、以及文件的仓库）
Git环境需要进行本地安装，官网https://git-scm.com/，通过自己的操作系统来选择合适的安装包进行下载安装并进行初始配置。
如在windows系统下，想将桌面的test文件夹作为某次开发的仓库，可以双击打开test文件夹，在空白处右键选择“git bash here”
即可打开bash命令行，然后直接在bash命令行中键入
1 git init 如果反馈信息如下，并在下一行等待输入，即创建版本库成功
1 Initialized empty Git repository in C:/Users/Admin/Desktop/test/.git/ 在test目录内创建rd.txt文本文件，并在其中写入”hello world”
继续在git bash 命令行中键入命令
1 git add rd.txt 这行命令的作用是将rd.txt作为预备提交文件进行添加
如果如下显示，则添加成功
接下来进行第一次提交，使用命令如下
1 git commit -m &amp;#34;&amp;lt;提交说明&amp;gt;&amp;#34; &amp;lt;提交说明&amp;gt;可以更改为自己的说明，如果显示如下，则提交成功
我们再将rd.txt进行一次修改，再进行第二次提交
然后我们现在可以键入以下命令，来查看当前仓库的日志
1 git log 如下所示
在黄色的commit后面长长的一串码是对应版本的版本号
我们现在假设产品经理告诉我们，第二次的修改是没有用的，那么我们就需要将版本回滚到第一版，也就是”my first commit”那一版，我们可以键入下面的命令
1 git reset --hard HEAD^ 可以看到反馈了如下信息
并且rd.txt和git log命令中，均只剩下第一次提交的内容，如下所示
这样就说明了我们回滚操作成功了
现在再假设产品经理告诉我们，他看错了，第二次修改的内容是需要的，那么这样我们就要退回回滚操作之前，只要当前bash命令行没有关闭，并且我们还能查到第二次的版本id，那么我们就能退回回滚操作之前，命令如下
1 git reset --hard &amp;lt;版本号&amp;gt; &amp;lt;版本号&amp;gt;应该填写自己命令行中的第二次提交的版本id，如下
看到这里，有很多小伙伴就会迷茫了，会问：刚才显示的第二次的版本id不是116b28f9460a5a0222ef0328c0c76e3c3fc95121吗？为什么我只写了一个116b2？
这是因为git的控制机制来说，我们只要能够给bash一个可以辨识到独一无二的版本号的序列，那么它就可以自动为我们匹配到我们想要去使用的版本号。
使用退回命令后，rd.txt内容显示如下，即表明我们的退回回滚操作之前的操作成功。
感谢您的阅读</description>
    </item>
    <item>
      <title>数据库中的GROUP BY与ORDER BY、WHERE与HAVING</title>
      <link>https://ocsxxi.top/posts/2018-12-20-2/</link>
      <pubDate>Thu, 20 Dec 2018 13:24:20 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2018-12-20-2/</guid>
      <description>在数据库的选择操作SELECT中经常会用到聚合条件，最常见也是最常用的是WHERE语句，故本文不会着重介绍WHERE语句。
现假设在某数据库中有一个名为PRODUCT的表，表结构及内部数据如下
1 2 3 4 5 CREATE TABLE PRODUCT( Pno CHAR(20) PRIMARY KEY, Pname CHAR(10), Pamount INT ); 1 2 3 4 5 6 7 8 9 +-----+-------+---------+ | Pno | Pname | Pamount | +-----+-------+---------+ | 001 | a | 1 | | 002 | a | 2 | | 003 | b | 1 | | 004 | b | 2 | | 005 | b | 6 | +-----+-------+---------+ ORDER BY 这一语句主要是显示排序用，如果选择了多条类似的记录，那么在查询语句中便可用到此语句，使用如下</description>
    </item>
    <item>
      <title>Hello World</title>
      <link>https://ocsxxi.top/posts/2018-12-20-1/</link>
      <pubDate>Thu, 20 Dec 2018 10:12:03 +0000</pubDate>
      <guid>https://ocsxxi.top/posts/2018-12-20-1/</guid>
      <description>欢迎大家来到我的个人博客</description>
    </item>
  </channel>
</rss>
