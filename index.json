[{"content":"为爱付出 为爱付出，是指某人主动达成或促成另一人或人群愿望，不计付出与收获进行实践的活动。\n另一人或人群的希望在此实践活动下得以被动完成。\n即使实践活动失败，实践主体也不会有怨言。\n自我感动 自我感动，是指某人主动向另一人或人群进行实践的活动。\n其初心是为了提升该人或人群生活质量，进一步优化该人或人群的发展需求与背景环境，但并不考虑该人或人群的实际需求。\n即使是在明确拒绝的情况下，实践活动依然会被实践主体完成。\n另一人或人群的希望在此实践活动下不会得以完成。\n特点是，在实践活动失败时，实践主体通常表现出极强的攻击性，强调自己宽宏的付出与无以为报，以显著或隐晦的方法促使另一人或人群内疚，迫使另一人或人群接受此实践活动所带来的积极或消极影响。\n另一特点是在自我感动活动被发现时，实践主体会以实践活动客体并非另一人或人群为理由掩盖主体的自我感动，但在实践活动失败时仍会暴露出其本质特点。\n两者的区别 主体付诸实践的目的条件不同。为爱付出是按他人意愿的付出，符合客观实际需求。自我感动是按实践主体意愿的付出，与客体实际需求毫无关联。\n付诸实践的结果不同。为爱付出无论实践活动的成功与否，均不会导致任意一方的埋怨。自我感动的实践活动失败时，会导致实践主体带有攻击倾向。\n特殊的付出活动：变质的付出 变质的付出有两种情况。\n第一种情况，是由为爱付出变质为自我感动。这种变质是向负向发展，通常产生的负面影响不会弱于自我感动，但多数情况下与自我感动产生的负面影响相当。此类情况界限较为模糊，常被实践主体用以模糊另一人或群体的认知，其实质是以爱为名进行的道德绑架。\n第二种情况，是由自我感动变质为为爱付出。这种变质是正向发展。变质产生的原因是另一人的实际需求由于各种条件变化而发生了改变，实践主体发现主动付出受到了另一人或群体的接纳。由负面活动得到了正向结果，从而产生了负反馈。这种反馈的恶劣影响最为严重，由于负反馈实际产生了正向结果，导致强化了实践主体的自我感动驱动力，后患无穷。\n自我感动纠偏建议 不仅需要及时指出实践主体的自我感动实践活动，还需要让实践主体理解透彻为爱付出和自我感动。\n通常情况下，实践主体极难以接受赤裸裸的现实，所以需要注意引导了解的方式方法，不能过于激进。也不建议在自我感动活动失败情况下进行引导纠偏。\n实践主体在理解区别后通常会有一个消极的适应期，用以思考自我价值与实践的辩证关系，但这个适应期不应超过两周，超过该周期可能会导致抑郁。\n注意：本文仅供参考。本文不能作为医疗处方的依据。\n","permalink":"https://ocsxxi.top/posts/2024-01-15-1/","summary":"为爱付出 为爱付出，是指某人主动达成或促成另一人或人群愿望，不计付出与收获进行实践的活动。\n另一人或人群的希望在此实践活动下得以被动完成。\n即使实践活动失败，实践主体也不会有怨言。\n自我感动 自我感动，是指某人主动向另一人或人群进行实践的活动。\n其初心是为了提升该人或人群生活质量，进一步优化该人或人群的发展需求与背景环境，但并不考虑该人或人群的实际需求。\n即使是在明确拒绝的情况下，实践活动依然会被实践主体完成。\n另一人或人群的希望在此实践活动下不会得以完成。\n特点是，在实践活动失败时，实践主体通常表现出极强的攻击性，强调自己宽宏的付出与无以为报，以显著或隐晦的方法促使另一人或人群内疚，迫使另一人或人群接受此实践活动所带来的积极或消极影响。\n另一特点是在自我感动活动被发现时，实践主体会以实践活动客体并非另一人或人群为理由掩盖主体的自我感动，但在实践活动失败时仍会暴露出其本质特点。\n两者的区别 主体付诸实践的目的条件不同。为爱付出是按他人意愿的付出，符合客观实际需求。自我感动是按实践主体意愿的付出，与客体实际需求毫无关联。\n付诸实践的结果不同。为爱付出无论实践活动的成功与否，均不会导致任意一方的埋怨。自我感动的实践活动失败时，会导致实践主体带有攻击倾向。\n特殊的付出活动：变质的付出 变质的付出有两种情况。\n第一种情况，是由为爱付出变质为自我感动。这种变质是向负向发展，通常产生的负面影响不会弱于自我感动，但多数情况下与自我感动产生的负面影响相当。此类情况界限较为模糊，常被实践主体用以模糊另一人或群体的认知，其实质是以爱为名进行的道德绑架。\n第二种情况，是由自我感动变质为为爱付出。这种变质是正向发展。变质产生的原因是另一人的实际需求由于各种条件变化而发生了改变，实践主体发现主动付出受到了另一人或群体的接纳。由负面活动得到了正向结果，从而产生了负反馈。这种反馈的恶劣影响最为严重，由于负反馈实际产生了正向结果，导致强化了实践主体的自我感动驱动力，后患无穷。\n自我感动纠偏建议 不仅需要及时指出实践主体的自我感动实践活动，还需要让实践主体理解透彻为爱付出和自我感动。\n通常情况下，实践主体极难以接受赤裸裸的现实，所以需要注意引导了解的方式方法，不能过于激进。也不建议在自我感动活动失败情况下进行引导纠偏。\n实践主体在理解区别后通常会有一个消极的适应期，用以思考自我价值与实践的辩证关系，但这个适应期不应超过两周，超过该周期可能会导致抑郁。\n注意：本文仅供参考。本文不能作为医疗处方的依据。","title":"为爱付出与自我感动"},{"content":"背景 Python 中 os 模块所提供的 listdir() 方法给出的序列，会由于执行器的编码情况而不同.在未设置的 cli 中使用 gbk 排序，在配置过的 IDE 中使用 UTF-8。\n无论是gbk还是UTF-8编码，均不是按照拼音排序，从而导致了与Windows资源管理器中的顺序不一致。\n解决 使用 pip 下载 natsort 包。\n其中有一个函数 os_sorted() 即与操作系统给出的文件顺序保持一致。\n使用 1 2 3 4 5 6 7 8 import os from natsort import os_sorted pwd = os.getcwd() # 获取当前目录 filenamelist = os.listdir(pwd) # ls该目录 sortedlist = os_sorted(filenamelist) # 即为排好序的文件列表 print(sortedlist) ","permalink":"https://ocsxxi.top/posts/2024-01-13-1/","summary":"背景 Python 中 os 模块所提供的 listdir() 方法给出的序列，会由于执行器的编码情况而不同.在未设置的 cli 中使用 gbk 排序，在配置过的 IDE 中使用 UTF-8。\n无论是gbk还是UTF-8编码，均不是按照拼音排序，从而导致了与Windows资源管理器中的顺序不一致。\n解决 使用 pip 下载 natsort 包。\n其中有一个函数 os_sorted() 即与操作系统给出的文件顺序保持一致。\n使用 1 2 3 4 5 6 7 8 import os from natsort import os_sorted pwd = os.getcwd() # 获取当前目录 filenamelist = os.listdir(pwd) # ls该目录 sortedlist = os_sorted(filenamelist) # 即为排好序的文件列表 print(sortedlist) ","title":"Python使用os.listdir时与windows资源管理器展示顺序不一致"},{"content":"背景 根据网络搜索引擎提供的解决方法，如 electron无边框模式完美解决同时实现拖动和双击最大化等，发现了：添加代码后，拖动窗口时窗口移动，但同时窗口大小发生意想不到的改变。\n解决 考虑到计算机图形是为了在屏幕上显示点阵图像，计算中会产生精度误差，从而导致图形抖动。\n尝试移动窗口前记录窗口尺寸，移动后重设窗口尺寸\n1 2 3 let oldsize = mainWindow.getSize() ... mainWindow.setSize(oldsize.width, oldsize.height) 运行尝试，并未达到预期效果。窗口大小仍然会发生大幅改变。\n网络上搜索不到相关内容，只能无尽的查api，发现另一个函数 xxxBounds()：\n1 2 3 4 5 let oldBounds = mainWindow.getBounds() ... oldBounds.x = x oldBounds.y = y mainWindow.setBounds(oldBounds, true) 注意这个函数与xxxSize()之间的差异，getBounds()会返回一个四个属性的对象，属性值分别为x-\u0026gt;x坐标，y-\u0026gt;y坐标，width-\u0026gt;窗口宽度，height-\u0026gt;窗口高度。\n所以在示例中将移动目标点的(x,y)坐标赋值修改至oldBounds，这样通过setBounds函数同时维护窗口的位置及维度。\n运行尝试，成功，窗口大小不会再发生大幅改变。试着读取窗口大小，变化幅度仅为1像素，长期拖动也不会出现问题。 出现该问题，并且搜不到相关问题解决方案，原因可能是我计算机的显示设置-缩放与布局设置的是125%（仅作猜想，未经验证！）\n","permalink":"https://ocsxxi.top/posts/2023-05-13-1/","summary":"背景 根据网络搜索引擎提供的解决方法，如 electron无边框模式完美解决同时实现拖动和双击最大化等，发现了：添加代码后，拖动窗口时窗口移动，但同时窗口大小发生意想不到的改变。\n解决 考虑到计算机图形是为了在屏幕上显示点阵图像，计算中会产生精度误差，从而导致图形抖动。\n尝试移动窗口前记录窗口尺寸，移动后重设窗口尺寸\n1 2 3 let oldsize = mainWindow.getSize() ... mainWindow.setSize(oldsize.width, oldsize.height) 运行尝试，并未达到预期效果。窗口大小仍然会发生大幅改变。\n网络上搜索不到相关内容，只能无尽的查api，发现另一个函数 xxxBounds()：\n1 2 3 4 5 let oldBounds = mainWindow.getBounds() ... oldBounds.x = x oldBounds.y = y mainWindow.setBounds(oldBounds, true) 注意这个函数与xxxSize()之间的差异，getBounds()会返回一个四个属性的对象，属性值分别为x-\u0026gt;x坐标，y-\u0026gt;y坐标，width-\u0026gt;窗口宽度，height-\u0026gt;窗口高度。\n所以在示例中将移动目标点的(x,y)坐标赋值修改至oldBounds，这样通过setBounds函数同时维护窗口的位置及维度。\n运行尝试，成功，窗口大小不会再发生大幅改变。试着读取窗口大小，变化幅度仅为1像素，长期拖动也不会出现问题。 出现该问题，并且搜不到相关问题解决方案，原因可能是我计算机的显示设置-缩放与布局设置的是125%（仅作猜想，未经验证！）","title":"无边框Electron拖动时窗口大小发生改变解决方法"},{"content":"背景 有需求如下\n打开某页面后在背景中自动播放视频，在页面不变，切出小程序后，再切回小程序，页面重新自动播放视频\n在编写之后，发现微信自身的配置并不能支持在小程序不销毁的情况下，在重新打开页面的时候重新播放视频\n解决 考虑到是否可以利用页面周期事件onHide与onShow，配合调用视频播放api进行播放\n编写onHide与onShow事件函数如下，假设videoContext是在onReady函数中已经获取好的视频组件句柄\n1 2 3 4 5 6 7 8 9 10 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ this.videoContext.play() this.pagehide = false } }, 运行尝试，并未达到预期效果\n恍惚间想起之前项目中碰到的微信小程序的坑，可能在当时重新打开微信小程序的一瞬间，句柄不能正常使用，尝试修改代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ this.$nextTick(()=\u0026gt;{ this.videoContext.play() }) this.pagehide = false } }, 运行尝试，这次发现有几率能够在重新打开页面时，恍惚间想起之前项目中碰到的微信小程序的解决方式，尝试修改代码如下 1 2 3 4 5 6 7 8 9 10 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ setTimeout(()=\u0026gt;{this.videoContext.play()},1) this.pagehide = false } }, 运行尝试，成功。 注：nextTick的实现机制与setTimeout的机制不一样，在微信小程序中，如果遇到类似的问题，都可以把nextTick换成setTimeout(fun(),1)试一试\n","permalink":"https://ocsxxi.top/posts/2022-06-07-1/","summary":"背景 有需求如下\n打开某页面后在背景中自动播放视频，在页面不变，切出小程序后，再切回小程序，页面重新自动播放视频\n在编写之后，发现微信自身的配置并不能支持在小程序不销毁的情况下，在重新打开页面的时候重新播放视频\n解决 考虑到是否可以利用页面周期事件onHide与onShow，配合调用视频播放api进行播放\n编写onHide与onShow事件函数如下，假设videoContext是在onReady函数中已经获取好的视频组件句柄\n1 2 3 4 5 6 7 8 9 10 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ this.videoContext.play() this.pagehide = false } }, 运行尝试，并未达到预期效果\n恍惚间想起之前项目中碰到的微信小程序的坑，可能在当时重新打开微信小程序的一瞬间，句柄不能正常使用，尝试修改代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 onHide() { this.pagehide = true }, onShow() { wx.hideHomeButton() if(this.pagehide){ this.$nextTick(()=\u0026gt;{ this.videoContext.play() }) this.pagehide = false } }, 运行尝试，这次发现有几率能够在重新打开页面时，恍惚间想起之前项目中碰到的微信小程序的解决方式，尝试修改代码如下 1 2 3 4 5 6 7 8 9 10 onHide() { this.","title":"微信小程序重新进入页面后自动播放视频不重播"},{"content":"背景 相信很多老前端做微信小程序点击样式的时候，都喜欢直接搁样式里:hover,:focus,:active三连，还有些时候真机调试压根没反应，\n时间长了，代码维护起来又累又辛苦。\n解决 多给组件设置一个hover-class，微信官方专门留给点击样式的。相关css代码全局写一个都够用了，妈妈再也不用担心我的样式表五米长了\n1 2 3 \u0026lt;view class=\u0026#34;...\u0026#34; hover-class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;/view\u0026gt; 其实还可以配合hover-stop-propagation属性使用，该属性接受布尔值，默认为false。如果设置为true则会阻止事件冒泡给父组件，可以有效提升代码执行速度。\n读文档要认真！\n嗯，吃一堑长一智，以后要尽量不以先入为主的观念看问题。\n","permalink":"https://ocsxxi.top/posts/2022-04-04-2/","summary":"背景 相信很多老前端做微信小程序点击样式的时候，都喜欢直接搁样式里:hover,:focus,:active三连，还有些时候真机调试压根没反应，\n时间长了，代码维护起来又累又辛苦。\n解决 多给组件设置一个hover-class，微信官方专门留给点击样式的。相关css代码全局写一个都够用了，妈妈再也不用担心我的样式表五米长了\n1 2 3 \u0026lt;view class=\u0026#34;...\u0026#34; hover-class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;/view\u0026gt; 其实还可以配合hover-stop-propagation属性使用，该属性接受布尔值，默认为false。如果设置为true则会阻止事件冒泡给父组件，可以有效提升代码执行速度。\n读文档要认真！\n嗯，吃一堑长一智，以后要尽量不以先入为主的观念看问题。","title":"微信小程序点击变更样式难设置"},{"content":"问题背景 如下方代码所示，该段代码在微信开发者工具内动画正常且流畅，但运行在ios设备中运行时发生动画卡顿，难以触发动画，且时常发生卡顿。\n1 2 3 \u0026lt;view animation={{animation}}\u0026gt; \u0026lt;img src=\u0026#34;...\u0026#34; mode=\u0026#34;widthFix\u0026#34; style=\u0026#34;width: 100%\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; 尝试解决的思路 把相同动画应用到文本按键上，在ios设备中运行时，按键动画展示丝滑且无闪烁，考虑是内容的问题。\n尝试将image组件更换为cover-image组件。我所设置的view外层有一个圆角，并且有一个缩放动画，在更改完组件后，圆角消失，动画变为了偏移而非缩放，也就是说小程序的animation变形并未作用到cover组件上，放弃这条路。\n（在微信官方文档中无论是在cover系列组件的章节，还是animation的章节，均未提到其是剥离文档流而存在这件事，算是个坑，也可呢是官方没想到会有人这么玩吧）\n尝试使用background-image样式来替换image组件，成功。 最终解决方案 把image图片设置未外层view的background-image就能完美解决了，亲测有效，在ios设备上展示丝滑，且不会发生图片闪烁。\n","permalink":"https://ocsxxi.top/posts/2022-04-04-1/","summary":"问题背景 如下方代码所示，该段代码在微信开发者工具内动画正常且流畅，但运行在ios设备中运行时发生动画卡顿，难以触发动画，且时常发生卡顿。\n1 2 3 \u0026lt;view animation={{animation}}\u0026gt; \u0026lt;img src=\u0026#34;...\u0026#34; mode=\u0026#34;widthFix\u0026#34; style=\u0026#34;width: 100%\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; 尝试解决的思路 把相同动画应用到文本按键上，在ios设备中运行时，按键动画展示丝滑且无闪烁，考虑是内容的问题。\n尝试将image组件更换为cover-image组件。我所设置的view外层有一个圆角，并且有一个缩放动画，在更改完组件后，圆角消失，动画变为了偏移而非缩放，也就是说小程序的animation变形并未作用到cover组件上，放弃这条路。\n（在微信官方文档中无论是在cover系列组件的章节，还是animation的章节，均未提到其是剥离文档流而存在这件事，算是个坑，也可呢是官方没想到会有人这么玩吧）\n尝试使用background-image样式来替换image组件，成功。 最终解决方案 把image图片设置未外层view的background-image就能完美解决了，亲测有效，在ios设备上展示丝滑，且不会发生图片闪烁。","title":"微信小程序设置动画API后图片闪动并且延迟高的解决方法"},{"content":"页面访问慢，架了cdn也没用？试试http2吧。\n以前的http连接，单次连接都是访问单个资源，http2就是在http连接的基础上，直接复用第一次建立http连接时的网络通路，不用每一次都要\u0026quot;三次挥手\u0026quot;啦。\n解决 原server的监听端口配置如下\n1 2 - listen 443 ssl; + listen 443 ssl http2; 即可开启http2的使用之旅啦。\n注 记得保证使用的nginx编译包含了with-http_v2_module模块，并且要保证同时启用ssl与http2。\n如果是通过\n1 apt install nginx 方式安装的nginx，那么通常来说已经默认编译包含了http2这个模块。\n如果不能确定是否包含了这个模块，则可以使用\n1 nginx -V 这个命令来查看自己使用的nginx是否编译包含了这个模块。\n","permalink":"https://ocsxxi.top/posts/2022-04-02-2/","summary":"页面访问慢，架了cdn也没用？试试http2吧。\n以前的http连接，单次连接都是访问单个资源，http2就是在http连接的基础上，直接复用第一次建立http连接时的网络通路，不用每一次都要\u0026quot;三次挥手\u0026quot;啦。\n解决 原server的监听端口配置如下\n1 2 - listen 443 ssl; + listen 443 ssl http2; 即可开启http2的使用之旅啦。\n注 记得保证使用的nginx编译包含了with-http_v2_module模块，并且要保证同时启用ssl与http2。\n如果是通过\n1 apt install nginx 方式安装的nginx，那么通常来说已经默认编译包含了http2这个模块。\n如果不能确定是否包含了这个模块，则可以使用\n1 nginx -V 这个命令来查看自己使用的nginx是否编译包含了这个模块。","title":"踩着油门建立的http连接——nginx开启http2"},{"content":"配置背景 大多数项目中，都会有没办法使用前端工程化方法维护的html页面，或者使用jade/pug(下文统称pug)技术来维护这些html页面。\n其实pug技术也不是全能的，毕竟还要经过一次编译，对本地环境需要有node.js的要求。\n对于不方便安装node.js的机器，开启nginx/httpd的ssi配置项能够极大的提高代码的可重用性。\n配置方法，以nginx为例 nginx是使用配置文件来描述提供服务的项目，对于那些需要开启ssi配置项的项目，可以在对应的server描述中添加下列配置项：\nssi on; ssi_silent_errors off; ssi_types text/html; 重启nginx或重载nginx配置项后，ssi功能便启用啦，详细的配置项字段值参考nginx文档https://nginx.org/en/docs/http/ngx_http_ssi_module.html\nssi的使用方法 他的使用方法，建议参考php的文件引入，两者功能很相似。\n\u0026lt;!-- #include file=\u0026#34;文件名称\u0026#34; --\u0026gt; \u0026lt;!-- #include virtual=\u0026#34;文件名称\u0026#34; --\u0026gt; file描述的是服务器上的绝对路径 virtual描述的是相对于服务器根目录的相对路径\n正确的使用ssi会极大的降低html的可维护性，读者可以自行尝试多种可能性，比如网站主题换肤(所有html共用模板文件，共同引入主题样式文件；或者引入子文件夹中的主题样式文件)。\n虽然ssi不能像webcomponent或pug那样灵活，但是相较于纯html项目来说已经是前进了一大步。\n","permalink":"https://ocsxxi.top/posts/2022-04-02-1/","summary":"配置背景 大多数项目中，都会有没办法使用前端工程化方法维护的html页面，或者使用jade/pug(下文统称pug)技术来维护这些html页面。\n其实pug技术也不是全能的，毕竟还要经过一次编译，对本地环境需要有node.js的要求。\n对于不方便安装node.js的机器，开启nginx/httpd的ssi配置项能够极大的提高代码的可重用性。\n配置方法，以nginx为例 nginx是使用配置文件来描述提供服务的项目，对于那些需要开启ssi配置项的项目，可以在对应的server描述中添加下列配置项：\nssi on; ssi_silent_errors off; ssi_types text/html; 重启nginx或重载nginx配置项后，ssi功能便启用啦，详细的配置项字段值参考nginx文档https://nginx.org/en/docs/http/ngx_http_ssi_module.html\nssi的使用方法 他的使用方法，建议参考php的文件引入，两者功能很相似。\n\u0026lt;!-- #include file=\u0026#34;文件名称\u0026#34; --\u0026gt; \u0026lt;!-- #include virtual=\u0026#34;文件名称\u0026#34; --\u0026gt; file描述的是服务器上的绝对路径 virtual描述的是相对于服务器根目录的相对路径\n正确的使用ssi会极大的降低html的可维护性，读者可以自行尝试多种可能性，比如网站主题换肤(所有html共用模板文件，共同引入主题样式文件；或者引入子文件夹中的主题样式文件)。\n虽然ssi不能像webcomponent或pug那样灵活，但是相较于纯html项目来说已经是前进了一大步。","title":"html组件化的必由之路——nginx开启ssi"},{"content":" 贴近下属，但也要远离下属。贴近下属的生活，原理下属的生活职业规划。如果想贴近下属的职业规划，争取为下属涨薪就是最好且最优的选择。\n学会察言观色。不是附和，而是知趣。别人不想听的时候，就不要浪费各自的时间了。\n培育下属固然重要，但不是拔苗助长，不是强行灌输自己的思想就一定能达到自己的目的，通常情况下都会适得其反。\n每个人都是隐藏的金子，要善于发现下属的优点并能让他得到成长，让他得到成长不是把本不该下属做的事分给下属做。发现优点是一个闪光的过程，不是让下属害怕优点被发现的过程。\n人是过程的集合，固然有一段经历会让人影响深刻，但这段经历不是止步不前的理由。\n当今的管理学有相当一部分的应用是错误的，不要照搬照抄，比如人效，只要保证每个人的工作能够顺利按时完成即可，只要份内工作做完了，哪怕坐在工位上打游戏看电影又有何妨。要求下属延长工时，又不发放福里，相互折磨不说，还会疏远管理者与下属之间的关系。\n管理者什么都会并不是一件好事，甚至很有可能动摇管理者的权威。什么都会，但什么都不精通，不管拿什么出来都会成为笑话。\n学会说话，要能委婉但又犀利地描述自己的观点。在照顾双方情感的基础上，不拖泥带水，不浪费时间。\n自降身段是拉近上下级关系的有效方法，但不是把手伸进别人的私人空间里。\n别人拍马屁是喜欢，但自升身段是纯属自恋。\n管理是要管在实处的，不是流于表象的，如果是演出来的管理，不如选择不浪费时间，至少不会疏远与下属间的关系。\n饼可以画，但是既然画了，就最好要做到，如果做不到，不如重新定一个小一点的可行目标。虽然可能给不了一个长久的未来，至少要证明现阶段的正确性。\n谨言慎行，每一句“随便”说出来的话都会把下属“随便”记住。口碑对于管理者也很重要。要学会多放下，多夸赞。\n“这个人有思想”应该是别人给自己的评价，不能是自评出来的。\n新想法的提出是要经过可行性论证的，不是每个新想法都百分百可行，不是每个新宪法都一定要落地，要选择性的使用这些想法。经过一段时间的沉淀之后冒出来的新想法是清爽可口的盐汽水；源源不断冒出来的新想法是在炉子上烧开105读的蒸馏水。\n","permalink":"https://ocsxxi.top/posts/2022-03-25-1/","summary":"贴近下属，但也要远离下属。贴近下属的生活，原理下属的生活职业规划。如果想贴近下属的职业规划，争取为下属涨薪就是最好且最优的选择。\n学会察言观色。不是附和，而是知趣。别人不想听的时候，就不要浪费各自的时间了。\n培育下属固然重要，但不是拔苗助长，不是强行灌输自己的思想就一定能达到自己的目的，通常情况下都会适得其反。\n每个人都是隐藏的金子，要善于发现下属的优点并能让他得到成长，让他得到成长不是把本不该下属做的事分给下属做。发现优点是一个闪光的过程，不是让下属害怕优点被发现的过程。\n人是过程的集合，固然有一段经历会让人影响深刻，但这段经历不是止步不前的理由。\n当今的管理学有相当一部分的应用是错误的，不要照搬照抄，比如人效，只要保证每个人的工作能够顺利按时完成即可，只要份内工作做完了，哪怕坐在工位上打游戏看电影又有何妨。要求下属延长工时，又不发放福里，相互折磨不说，还会疏远管理者与下属之间的关系。\n管理者什么都会并不是一件好事，甚至很有可能动摇管理者的权威。什么都会，但什么都不精通，不管拿什么出来都会成为笑话。\n学会说话，要能委婉但又犀利地描述自己的观点。在照顾双方情感的基础上，不拖泥带水，不浪费时间。\n自降身段是拉近上下级关系的有效方法，但不是把手伸进别人的私人空间里。\n别人拍马屁是喜欢，但自升身段是纯属自恋。\n管理是要管在实处的，不是流于表象的，如果是演出来的管理，不如选择不浪费时间，至少不会疏远与下属间的关系。\n饼可以画，但是既然画了，就最好要做到，如果做不到，不如重新定一个小一点的可行目标。虽然可能给不了一个长久的未来，至少要证明现阶段的正确性。\n谨言慎行，每一句“随便”说出来的话都会把下属“随便”记住。口碑对于管理者也很重要。要学会多放下，多夸赞。\n“这个人有思想”应该是别人给自己的评价，不能是自评出来的。\n新想法的提出是要经过可行性论证的，不是每个新想法都百分百可行，不是每个新宪法都一定要落地，要选择性的使用这些想法。经过一段时间的沉淀之后冒出来的新想法是清爽可口的盐汽水；源源不断冒出来的新想法是在炉子上烧开105读的蒸馏水。","title":"如何做一名好的管理者"},{"content":"公式 行列式 $|A| = a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}(按行展开)$\n$\\quad \\ = a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}(按行展开)$\n特别的\n（1）上、下三角行列式：主对角元素的乘积\n$$ \\left|\\begin{matrix} \u0026amp; a_{12} \u0026amp; \u0026amp; \\cdots \u0026amp; a_{1n} \\\\ \u0026amp; \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp;a_{2n} \\\\ \u0026amp; \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp;a_{nn}\\end{matrix}\\right|=\\left|\\begin{matrix}a_{11} \u0026amp; \u0026amp; \u0026amp; \\\\a_{21} \u0026amp; a_{22} \u0026amp; \u0026amp; \\\\\\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp;a_{nn}\\end{matrix}\\right|=\\left|\\begin{matrix}a_{11} \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp; a_{22} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp;a_{nn}a_{11}\\end{matrix}\\right| $$\n（2）副上、下三角行列式：副对角元素的乘积 $\\ *\\ (-1)^{\\frac{n(n-1)}{2}}$\n（3）拉普拉斯展开式：\n$\\left|\\begin{array}{cccc}A \u0026amp; 0\\\\ C \u0026amp; B\\\\ \\end{array}\\right|=\\left|\\begin{array}{cccc}A \u0026amp; C\\\\ 0 \u0026amp; B\\\\ \\end{array}\\right|=|A||B|$\n$\\left|\\begin{array}{cccc}C \u0026amp; A\\\\ B \u0026amp; 0\\\\ \\end{array}\\right|=\\left|\\begin{array}{cccc}0 \u0026amp; A\\\\ B \u0026amp; C\\\\ \\end{array}\\right|=(-1)^{m\\ *\\ n}|A||B|$\n（4）范德蒙行列式：大指标减小指标的连乘积\n$\\left|\\begin{array}{cccc}1 \u0026amp; 1 \u0026amp; 1 \\\\ x_1 \u0026amp; x_2 \u0026amp;x_3\\\\ x_1^2\u0026amp; x_2^2 \u0026amp; x_3^2 \\end{array}\\right|=(x_2-x_1)(x_3-x_1)(x_3-x_2)$\n矩阵 （1）转置\n$(A^T)^T = A, \\qquad\\qquad\\ (A+B)^T=A^T+B^T$\n$(kA)^T=kA^T, \\qquad\\quad (AB)^T=B^TA^T$\n（2）伴随\n$A^*=|A|A^{-1}$\n$AA^{*}=A^{*}A=|A|E, \\qquad (A^{*})^T=(A^T)^{*}$\n$(kA)^{*}=k^{n-1}A^{*}, \\qquad\\qquad (A^{*})^{*}=|A|^{n-2}A$\n$(A^{*})^{-1}=(A^{-1})^{*}=\\cfrac{1}{|A|}A$\n$R(A^{*})=\\left \\{ \\begin{array}{ll}n, \u0026amp; R(A)=n \\\\ 1, \u0026amp; R(A)=n-1 \\\\ 0, \u0026amp; R(A)\u0026lt;n-1 \\end{array} \\right.$\n（3）可逆\n$(A^{-1})^{-1}=A$\n$(kA^{-1})=\\cfrac{1}{k}A^{-1} \\qquad\\qquad, (AB)^{-1}=B^{-1}A^{-1}$\n$(A^n)^{-1}=(A^{-1})^n \\qquad\\quad\\ \\ , (A^{-1})^T=(A^T)^{-1}$\n特别的，初等矩阵：\n互换两行或两列，矩阵不变\n$\\left(\\begin{array}{cccc} \u0026amp; 1 \u0026amp; \\\\ 1 \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{array}\\right)^{-1}=\\left(\\begin{array}{cccc} \u0026amp; 1 \u0026amp; \\\\ 1 \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{array}\\right)$\n倍乘某行或某列，取倒数\n$\\left(\\begin{array}{cccc} 1 \u0026amp; \u0026amp; \\\\ \u0026amp; k \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{array}\\right)^{-1}=\\left(\\begin{array}{cccc} 1 \u0026amp; \u0026amp; \\\\ \u0026amp; \\cfrac{1}{k} \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{array}\\right)$\n倍加某行或某列，加负号\n$\\left(\\begin{array}{cccc} 1 \u0026amp; \u0026amp; k \\\\ \u0026amp; 1 \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{array}\\right)^{-1}=\\left(\\begin{array}{cccc} 1 \u0026amp; \u0026amp; -k \\\\ \u0026amp; 1 \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{array}\\right)$\n（5）方阵的行列式\n$|A^T|=|A|$\n$|kA| = k^n|A| \\qquad |AB|=|A||B|$\n$|A^*|=|A|^{n-1} \\qquad |A^{-1}|=\\cfrac{1}{|A|}$\n特征值 （1） $|A|=\\prod\\lambda_i \\qquad \\prod\\lambda_i=\\sum a_{ii}$\n（2）$A\\alpha=\\lambda\\alpha，则(A+kE)\\alpha=(\\lambda+k)\\alpha$\n$\\qquad\\ \\ A^n\\alpha=\\lambda^n\\alpha \\qquad A^{-1}\\alpha=\\cfrac{1}{\\lambda}\\alpha \\qquad A^*\\alpha=\\cfrac{|A|}{\\lambda}\\alpha$\n$\\qquad\\ \\ (P^{-1}AP)(P^{-1}\\alpha)=\\lambda P^{-1}\\alpha$\n（3）如$A \\sim B$，则：\n$\\qquad\\ \\ |A|=|B|,\\quad R(A)=R(B),\\quad \\lambda_A=\\lambda_B, \\quad \\sum a_{ii}=\\sum b_{ii}$\n（4）如$A \\sim B$，即$P^{-1}AP=B$，则：\n$\\qquad\\ \\ P^{-1}(A+kE)P=B+kE, \\qquad P^{-1}A^nP=B^n$\n施密特正交化 $\\beta_1=\\alpha_1$\n$\\beta_2=\\alpha_2-\\cfrac{[\\beta_1, \\alpha_2]}{[\\beta_1, \\beta_1]}\\beta_1$\n$\\beta_3=\\alpha_3-\\cfrac{[\\beta_2, \\alpha_3]}{[\\beta_2, \\beta_2]}\\beta_2-\\cfrac{[\\beta_1, \\alpha_3]}{[\\beta_1, \\beta_1]}\\beta_1$\n定理 $A$ 是 $n$ 阶可逆矩阵\n$\\qquad \\Leftrightarrow \\quad |A|\\neq0$\n$\\qquad \\Leftrightarrow \\quad r(A)=n$\n$\\qquad \\Leftrightarrow \\quad A的行/列向量组线性无关$\n$\\qquad \\Leftrightarrow \\quad 齐次方程组Ax=0只有零解$\n$\\qquad \\Leftrightarrow \\quad \\forall\\ b\\in R^n,\\ Ax=b总有唯一解$\n$\\qquad \\Leftrightarrow \\quad A与E等价$\n$\\qquad \\Leftrightarrow \\quad A可表示成若干个初等矩阵的乘积$\n$\\qquad \\Leftrightarrow \\quad A的特征值全不为0$\n设$A_{\\ m \\times n\\ }，则其次方程组\\ Ax=0\\ 有非0解$\n$\\qquad \\Leftrightarrow \\quad r(A)\u0026lt;n$\n$\\qquad \\Leftrightarrow \\quad A的列向量组线性无关$\n特别地，\n如果 $m\u0026lt;n$，则$Ax=0$必有非0解\n如果 $A_n$，则$Ax=0$有非0解 $\\Leftrightarrow |A|=0$\n设$A_{\\ m \\times n\\ }，r(A)=r\u0026lt;n，则\\ Ax=0\\ 解集合的秩为n-r$\n设$A_{\\ m \\times n\\ }，r(A)=r(\\bar A)=r\u0026lt;n，则方程组\\ Ax=b\\ 的通解为$\n$$\\alpha + k_1\\eta_1+k_2\\eta_2+\\dots+k_{n-r}\\eta_{n-r}$$\n其中$\\alpha$是方程组$Ax=b$的一个解，$\\eta_1,\\eta_2,\\dots,\\eta_{n-r}$是$Ax=0$的基础解系\n特征值不同，特征向量线性无关\n特别地，实对称矩阵，不同特征值所对应的特征向量均正交\n$k$重特征值至多有$k$个线性无关的特征向量\n$A \\sim \\Lambda\\ \\Leftrightarrow\\ A有n个线性无关的特征向量$\n$\\qquad\\quad \\ \\Leftrightarrow\\ 如\\ \\lambda\\ 是k重特征值，则n-r(\\lambda E-A)=k$\n特别地，\n$A$是是对称矩阵，则$A \\sim \\Lambda$\n$A$有$n$个不同的特征值，则$A \\sim \\Lambda$\n如 $P^{-1}AP=\\Lambda$ 则 $\\Lambda 为 A$的特征值，$P为A$的特征向量\n$n$维向量 $\\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_n$ 线性相关\n$\\Leftrightarrow \\qquad 存在一组不全为0的数\\ k_1,\\ k_2,\\ \\dots\\ k_s$\n$\\qquad\\quad;$使得 $\\sum\\limits_{i=1}^sk_i\\alpha_i=0$ 成立\n$\\Leftrightarrow \\qquad ( \\alpha_1, \\alpha_2, \\dots, \\alpha_s)\\left(\\begin{array}{cccc} x_1\\\\ x_2\\\\ \\vdots\\\\ x_s \\end{array}\\right)=0\\ 有非零解$；$即$Ax=0$有非零解\n$\\Leftrightarrow \\qquad R( \\alpha_1, \\alpha_2, \\dots, \\alpha_s) \u0026lt; s，系数矩阵的秩小于未知数的个数$\n特别地\n(1) $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_n$ 线性相关 $\\ \\Leftrightarrow\\ |\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_n|=0$\n(2) $\\ s\u0026gt;n$时， $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$必线性相关\n设向量组 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 线性无关， $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s,\\ \\beta$ 线性相关，则 $\\beta$ 可由 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_n$ 线性表出且表示方法唯一。\n若 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 线性相关，则 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s,\\ \\alpha_{s+1}$ 必线性相关\n若 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 线性无关，则 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_{s-1}$ 必线性无关\n若 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 线性无关，则$\\left[\\begin{array}{cccc}\\alpha_1\\\\ \\beta_1\\end{array}\\right]，\\left[\\begin{array}{cccc}\\alpha_2\\\\ \\beta_2\\end{array}\\right]，\\dots , \\left[\\begin{array}{cccc}\\alpha_s\\\\ \\beta_s\\end{array}\\right]$ 必线性无关\n若 $\\left[\\begin{array}{cccc}\\alpha_1\\\\ \\beta_1\\end{array}\\right]，\\left[\\begin{array}{cccc}\\alpha_2\\\\ \\beta_2\\end{array}\\right]，\\dots , \\left[\\begin{array}{cccc}\\alpha_s\\\\ \\beta_s\\end{array}\\right]$ 线性相关，则 $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 均线性相关\n如向量组A: $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 可由 向量组B: $\\ \\beta_1,\\ \\beta_2，\\ \\dots\\ \\beta_t$线性表出，则$R(A)\u0026lt;R(B)$\n如向量组A: $\\ \\alpha_1,\\ \\alpha_2，\\ \\dots\\ \\alpha_s$ 可由 向量组B: $\\ \\beta_1,\\ \\beta_2，\\ \\dots\\ \\beta_t$线性表出，且A线性无关，则$s\u0026lt;t$\n二次型 $x^TAx$ 经坐标变换 $x=cy$ 得新二次型 $y^TBy$其中 $B=C^TAC$，即经坐标变换二次型的矩阵A和B合同\n二次型 $x^TAx$，必存在正交变换 $x=Qy$ ,得标准型 $x^TAx=y^T\\Lambda y=\\lambda_1y_1^2+\\lambda_2y_2^2+\\dots+\\lambda_ny_n^2$\n其中 $\\lambda_1\\ \\lambda_2\\ \\dots\\ \\lambda_n$ 是A的特征值，$ Q=(\\gamma_1, \\gamma_2, \\dots, \\gamma_n) $ 是A的特征向量\n$n$ 元二次型$x^TAx$为正定： $\\Leftrightarrow$ A的正惯性指数为n\n$\\Leftrightarrow$ A与E合同，即存在可逆矩阵C，使得$C^TAC=E$\n$\\Leftrightarrow$ A的所有特征值均为正数\n$\\Leftrightarrow$ A的各阶顺序主子式均大于0\n$\\Rightarrow a_{ii}\u0026gt;0，|A|\u0026gt;0$（必要条件）\n秩的相关定理 $R(A)=n A中有n阶子式不为0，且n+1阶子式全为0$\n$R(A)\u0026lt;n A中有n阶子式全为0$\n$R(A)\\geq n A中有n阶子式不为0$\n经过初等变换后矩阵的秩不变\n$R(A)\\ =\\ A的列向量组的秩\\ =\\ A的行向量组的秩$\n公式 $0\\ \\leq\\ R(A_{m\\ *\\ n})\\ \\leq\\ min(m, n)$\n$R(A^T)\\ =\\ R(A)$\n$R(kA) = R(A), k\\neq 0$\n$R(A+B)\\ \\leq\\ R(A)\\ + R(B)$\n$R(AB)\\ \\leq\\ min(R(A), R(B))$\n若对于$P、Q\\quad \\exists \\ P^{-1}、Q^{-1}，$\n$则R(A)=R(PA)=R(AQ)=R(PAQ)$\n$max(RA, RB)\\ \\leq\\ R(A, B)\\ \\leq\\ R(A)+R(B)$\n$R(A^TA)=R(A)$\n$\\qquad\\quad R\\left[\\begin{array}{cccc}A \u0026amp; 0 \\\\ 0 \u0026amp; B\\end{array}\\right]=R(A)+R(B)$\n设$A_{m\\ *\\ n}，\\ B_{n\\ *\\ s}，且AB=0，则RA+RB\\leq n$\n特别地，\n如果$RA=1$，则\n$A^2=(\\ \\sum a_{ii}\\ ) * A$\n$|\\lambda E-A|=\\lambda^n-\\sum a_{ii}\\lambda^{n-1}$\n即A的特征值：$\\left\\{\\begin{array}{ll}\\lambda_1=\\sum a_{ii} \\\\ \\lambda_2 = 0 \\\\ \\vdots \\qquad \\vdots \\\\ \\lambda_n = 0\\end{array}\\right.$\n","permalink":"https://ocsxxi.top/posts/2020-12-20-1/","summary":"公式 行列式 $|A| = a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}(按行展开)$\n$\\quad \\ = a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}(按行展开)$\n特别的\n（1）上、下三角行列式：主对角元素的乘积\n$$ \\left|\\begin{matrix} \u0026amp; a_{12} \u0026amp; \u0026amp; \\cdots \u0026amp; a_{1n} \\\\ \u0026amp; \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp;a_{2n} \\\\ \u0026amp; \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp;a_{nn}\\end{matrix}\\right|=\\left|\\begin{matrix}a_{11} \u0026amp; \u0026amp; \u0026amp; \\\\a_{21} \u0026amp; a_{22} \u0026amp; \u0026amp; \\\\\\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp;a_{nn}\\end{matrix}\\right|=\\left|\\begin{matrix}a_{11} \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp; a_{22} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp;a_{nn}a_{11}\\end{matrix}\\right| $$","title":"线性代数公式定理 (李永乐版)"},{"content":"问题描述 现在，在我国来看，无论大中小三种企业，均喜欢使用软件工程过程中的“敏捷模型”。\n使用了“敏捷模型”的企业，大多的软件流程如下：\n产品经理产出原型\n架构师/主管开始拆分模块并分配至开发人员\n产品经理开始补文档\n这种方法虽然开发速度快，但是实际上，整个开发团队对于需求的理解是模糊的。\n这种流程，在需求确认的时候，无法拿出一份符合软件行业规范的文档，仅仅以原型作为展示，来与客户、开发、测试等人员进行沟通。\n实际上，纵观软件工程的发展史，我们就会发现，一切回到了最初的起点：软件危机。\n仅使用原型来与客户进行需求确认，导致客户确认的需求比较模糊\n架构/主管按照原型进行模块划分，导致软件整体架构是按照当前需求最优的，后期需求一旦变更，就会导致大面积的代码变更\n模块虽不会对开发人员产生模糊，但是由于需求实际上并不是“确认”的，开发人员将可能产出错误的软件实现。\n将对测试人员的工作产生巨大的影响，比如，测试人员认为有问题，但是开发人员认为没问题，产品经理也坚持没问题/下一版再说。\n缺少文档、需求模糊、更改耗时耗力、一再拖拉，传说中的软件危机就这样再一次出现了。\n如何避免和改善： 一日没有《需求分析说明书》，开发人员和测试人员就一日不应工作。\n","permalink":"https://ocsxxi.top/posts/2020-11-15-2/","summary":"问题描述 现在，在我国来看，无论大中小三种企业，均喜欢使用软件工程过程中的“敏捷模型”。\n使用了“敏捷模型”的企业，大多的软件流程如下：\n产品经理产出原型\n架构师/主管开始拆分模块并分配至开发人员\n产品经理开始补文档\n这种方法虽然开发速度快，但是实际上，整个开发团队对于需求的理解是模糊的。\n这种流程，在需求确认的时候，无法拿出一份符合软件行业规范的文档，仅仅以原型作为展示，来与客户、开发、测试等人员进行沟通。\n实际上，纵观软件工程的发展史，我们就会发现，一切回到了最初的起点：软件危机。\n仅使用原型来与客户进行需求确认，导致客户确认的需求比较模糊\n架构/主管按照原型进行模块划分，导致软件整体架构是按照当前需求最优的，后期需求一旦变更，就会导致大面积的代码变更\n模块虽不会对开发人员产生模糊，但是由于需求实际上并不是“确认”的，开发人员将可能产出错误的软件实现。\n将对测试人员的工作产生巨大的影响，比如，测试人员认为有问题，但是开发人员认为没问题，产品经理也坚持没问题/下一版再说。\n缺少文档、需求模糊、更改耗时耗力、一再拖拉，传说中的软件危机就这样再一次出现了。\n如何避免和改善： 一日没有《需求分析说明书》，开发人员和测试人员就一日不应工作。","title":"现代软件工程“敏捷模型”的个人看法"},{"content":"软件的定义 根据《软件工程》的规定，\n软件 = 文档 + 数据 + 程序\n我们能了解到，程序只是软件的一部分。\n我们也可以获得软件的定义：\n软件是采用了适当的算法与数据结构，并拥有完备的软件描述信息的一套指令的集合。\n软件工程的关注点 我们都知道，（一套高质量的）程序是软件工程的最终目标，但是，程序并不是软件工程的关注点，文档与过程才是。\n软件过程的开始 当项目立项后，可行性分析认为**“可行”**时，就正式的进入了软件工程过程。\n（在这里，我不将可行性分析阶段算入软件工程过程，因为若可行性分析的结果是“不可行”，那么软件将不会存在）\n软件过程的核心文档 《需求分析说明书》将成为了软件的第一个部分。它是软件工程过程中，最重要，也是最容易出现问题的部分。\n当进入了需求分析阶段时，以最普遍的W模型来看，意味着测试工程师可以开始工作了，也即整个软件团队的成员都需要开始工作了。《需求分析说明书》就像一块凝结核，软件会在这个“凝结核”的基础上逐渐生长，慢慢成为坚固的“晶体结构”。\n程序与软件的对比 我们再反观程序。程序就不一样了，在程序中，一定要有可运行的计算机代码，如果没有可运行的计算机代码，那么程序只能叫做算法，或是PDL。相比较于软件的“晶体结构”，程序就是一盘”散沙”，虽然掺点水可以做成沙堡，但是非常脆弱。\n广义化的软件 那么站在软件工程过程上来说，我们就可以这样广义化描述：\n当文档开始进入了软件工程过程时，即可被称之为软件。\n在这种描述下，软件可以（在软件过程中）脱离程序而独立存在，也可以结合程序达到最终目标，但软件绝对不等价于程序。\n","permalink":"https://ocsxxi.top/posts/2020-11-15-1/","summary":"软件的定义 根据《软件工程》的规定，\n软件 = 文档 + 数据 + 程序\n我们能了解到，程序只是软件的一部分。\n我们也可以获得软件的定义：\n软件是采用了适当的算法与数据结构，并拥有完备的软件描述信息的一套指令的集合。\n软件工程的关注点 我们都知道，（一套高质量的）程序是软件工程的最终目标，但是，程序并不是软件工程的关注点，文档与过程才是。\n软件过程的开始 当项目立项后，可行性分析认为**“可行”**时，就正式的进入了软件工程过程。\n（在这里，我不将可行性分析阶段算入软件工程过程，因为若可行性分析的结果是“不可行”，那么软件将不会存在）\n软件过程的核心文档 《需求分析说明书》将成为了软件的第一个部分。它是软件工程过程中，最重要，也是最容易出现问题的部分。\n当进入了需求分析阶段时，以最普遍的W模型来看，意味着测试工程师可以开始工作了，也即整个软件团队的成员都需要开始工作了。《需求分析说明书》就像一块凝结核，软件会在这个“凝结核”的基础上逐渐生长，慢慢成为坚固的“晶体结构”。\n程序与软件的对比 我们再反观程序。程序就不一样了，在程序中，一定要有可运行的计算机代码，如果没有可运行的计算机代码，那么程序只能叫做算法，或是PDL。相比较于软件的“晶体结构”，程序就是一盘”散沙”，虽然掺点水可以做成沙堡，但是非常脆弱。\n广义化的软件 那么站在软件工程过程上来说，我们就可以这样广义化描述：\n当文档开始进入了软件工程过程时，即可被称之为软件。\n在这种描述下，软件可以（在软件过程中）脱离程序而独立存在，也可以结合程序达到最终目标，但软件绝对不等价于程序。","title":"有关软件的讨论"},{"content":" 软件工程师 程序员/码农 学历要求 本科及以上 专科及以上 工作 内容 设计并完善软件系统， 保障软件代码的高可重用性 写代码，能运行就行 职位 设计者 实施者 软件工程 注重软件工程流程 无 框架语言要求 低 高 软技能要求（代码洁癖、 计算机原理、算法等） 高 低 文档能力 高 低 工作中的关注点 人机交互 功能正确 团队精神与协作能力 高 中 需求理解能力 高 低 模块化思维能力 高 中 数学与建模能力 高 低 测试能力 高 低 工作量 中 高 从事工作技术含量 高 低 英语 高 低 进度与质量把控 高 低 自我驱动力 高 低 工作交付时完成的任务 需求文档\n软件代码\n软件设计书\n单元测试\n集成测试\n系统测试\nUI测试\n交付说明书\n软件使用说明书\n…… 软件代码\n功能测试 最终目标 提升人们的生活质量 挣钱 ","permalink":"https://ocsxxi.top/posts/2020-10-31-1/","summary":"软件工程师 程序员/码农 学历要求 本科及以上 专科及以上 工作 内容 设计并完善软件系统， 保障软件代码的高可重用性 写代码，能运行就行 职位 设计者 实施者 软件工程 注重软件工程流程 无 框架语言要求 低 高 软技能要求（代码洁癖、 计算机原理、算法等） 高 低 文档能力 高 低 工作中的关注点 人机交互 功能正确 团队精神与协作能力 高 中 需求理解能力 高 低 模块化思维能力 高 中 数学与建模能力 高 低 测试能力 高 低 工作量 中 高 从事工作技术含量 高 低 英语 高 低 进度与质量把控 高 低 自我驱动力 高 低 工作交付时完成的任务 需求文档\n软件代码\n软件设计书\n单元测试\n集成测试\n系统测试\nUI测试\n交付说明书\n软件使用说明书","title":"软件工程师与程序员对比"},{"content":"一、古典概型 摸球问题\n一把抓（无序）： 组合\n逐个取（有序）：\n不放回： $n\\Omega$ 要逐渐减小 放回【独立】：$n\\Omega$不变 抽签摸奖与次序无关：若a个中奖球，b个不中奖球，前n-1次不明确，那么第n次中奖的的概率即$\\frac{a}{a+b}$\n分房问题\n指定 （不用选） 恰 （需要选） 人数要求 取样问题\n含与不含 或与且 最大与最小 二、几何概型 长度、面积、体积的比值\n三、事件的运算 包含、相等、和、积、差、互不相容、对立\n$P(A-B)=P(A\\bar{B})=P(A)-P(AB)$\n互不相容 ：$AB=\\phi$\n对立 ：$AB=\\phi$ 且 $A+B=\\Omega$ ( P(AB)=P($\\bar{A}\\bar{B}$) )\n互不相容 $\\overset{\\nrightarrow}{\\leftarrow}$ 对立\n事件关系 $\\overset{\\nleftarrow}{\\rightarrow}$ 概率关系\n概率等式关系\n$P(AB)\\overset{独立}{=}P(A)P(B)$ P($A_先B_后$) $\\overset{乘}{=}$ P(A) P(B|A) P(AB) $\\overset{加}{=}$ P(A) + P(B) -P(A+B) P(AB) $\\overset{减}{=}$ P(A) - P(A$\\bar{B}$) = P(B) - P($\\bar{A}$B) P(AB) $\\overset{对立}{=}$ 1 - P($\\overline{AB}$) = 1 - P($\\bar{A} \\bigcup \\bar{B}$) 四、概率不等式关系 0 $\\leq$ P(A) $\\leq$ 1 A$\\subset$B $\\Longrightarrow$ P(A) $\\leq$ P(B) P(B|A) \u0026gt; P(AB) AB $\\subseteq$ A $\\Longrightarrow$ P(AB) $\\leq$ P(A)\nAB $\\subseteq$ B $\\Longrightarrow$ P(AB) $\\leq$ P(B)\n$\\Longrightarrow$ P(AB) $\\leq$ $\\frac{P(A)+P(B)}{2}$\n$\\Longrightarrow$ P(AB) $\\leq$ min[ P(A)， P(B) ]\nP(AB) $\\overset{加}{=}$ P(A) + P(B) - P(A+B)\nP(A+B) $\\in$ [ 0, 1 ]\n$\\Longrightarrow$ P(AB) $\\geq$ P(A) + P(B) -1\n五、条件概率与乘法公式 条件概率也是概率，其满足概率的一切性质\n$$P(B|A)=\\frac{P(AB)}{P(A)}$$\nP(ABC) = P(A)P(B|A)P(C|AB)\n条件概率的计算：\n抽象：扣定义 具体：缩小样本空间 逆概：Bayes公式 P(A|B)与P(A)的大小关系(P(A)\u0026gt;0,P(B)\u0026gt;0)\n当A$\\subset$B时 P(A|B) = $\\frac{P(AB)}{P(B)}$ = $\\frac{P(A)}{P(B)}$ $\\geq$ P(A) 当B$\\subset$A时 P(A|B) = $\\frac{P(B)}{P(B)}$ = 1 $\\geq$ P(A) 当AB=$\\phi$时 P(A|B) = 0 $\\leq$ P(A) 当P(AB)=P(A)P(B)时 P(A|B) = $\\frac{P(AB)}{P(B)}$ = $\\frac{P(A)P(B)}{P(B)}$ = P(A) 六、独立性与伯努利 独立：P(AB)=P(A)P(B)\n独立等价：\nP(B|A) = P(B|$\\bar{A}$) P(B|A) = $\\frac{P(AB)}{P(A)}$ = P(B) P(B|A) = P($\\bar{B}$|$\\bar{A}$) = 1 若事件A与B相互独立，则“爱逆不逆”（即事件A发生条件下，对事件B的概率毫无影响）\n判定两事件独立：\n靠先前经验判断 独立性的意义$\\longrightarrow$有放回的抽样 扣定义 多事件间的独立性：\nA,B,C$\\underline{两两}$独立 $\\begin{cases} P(AB) = P(A)P(B)\\\\ P(AC) = P(A)P(C) \\\\ P(BC) = P(B)P(C) \\end{cases}$\nA,B,C$\\underline{相互}$独立 $\\begin{cases} P(AB) = P(A)P(B) \\\\ P(AC) = P(A)P(C) \\\\ P(BC) = P(B)P(C) \\\\ \\underline{\\text{P(ABC) = P(A)P(B)P(C)}}\\end{cases}$\nn重伯努利事件（n重独立重复试验）（结果只有A和$\\bar{A}$，P(A)=p，P($\\bar{A}$)=1-p，也即二项分布）\nn次试验成功k次 ：$C_n^kp^k(1-p)^{n-k}$\n直到第n次成功了k次：$C_{n-1}^{k-1}p^k(1-p)^{n-k}$\n（即 n-1次试验成功了k-1次： $C_{n-1}^{k-1}p^{k-1}(1-p)^{(n-1)-(k-1)}*p$ ）\n七、全概率公式与贝叶斯公式 完备事件组构造方法：$\\begin{cases} \\text{两分法} \\\\ \\text{按离散随机变量取值} \\\\ \\text{广义化} \\end{cases}$\n全概率公式（由因得果）：$P(B)=\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)$\n贝叶斯公式（由果溯因）：$P(A_j|B)=\\frac{P(A_j)P(B|A_j)}{P(B)}=\\frac{P(A_j)P(B|A_j)}{\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)}$\n","permalink":"https://ocsxxi.top/posts/2020-10-30-1/","summary":"一、古典概型 摸球问题\n一把抓（无序）： 组合\n逐个取（有序）：\n不放回： $n\\Omega$ 要逐渐减小 放回【独立】：$n\\Omega$不变 抽签摸奖与次序无关：若a个中奖球，b个不中奖球，前n-1次不明确，那么第n次中奖的的概率即$\\frac{a}{a+b}$\n分房问题\n指定 （不用选） 恰 （需要选） 人数要求 取样问题\n含与不含 或与且 最大与最小 二、几何概型 长度、面积、体积的比值\n三、事件的运算 包含、相等、和、积、差、互不相容、对立\n$P(A-B)=P(A\\bar{B})=P(A)-P(AB)$\n互不相容 ：$AB=\\phi$\n对立 ：$AB=\\phi$ 且 $A+B=\\Omega$ ( P(AB)=P($\\bar{A}\\bar{B}$) )\n互不相容 $\\overset{\\nrightarrow}{\\leftarrow}$ 对立\n事件关系 $\\overset{\\nleftarrow}{\\rightarrow}$ 概率关系\n概率等式关系\n$P(AB)\\overset{独立}{=}P(A)P(B)$ P($A_先B_后$) $\\overset{乘}{=}$ P(A) P(B|A) P(AB) $\\overset{加}{=}$ P(A) + P(B) -P(A+B) P(AB) $\\overset{减}{=}$ P(A) - P(A$\\bar{B}$) = P(B) - P($\\bar{A}$B) P(AB) $\\overset{对立}{=}$ 1 - P($\\overline{AB}$) = 1 - P($\\bar{A} \\bigcup \\bar{B}$) 四、概率不等式关系 0 $\\leq$ P(A) $\\leq$ 1 A$\\subset$B $\\Longrightarrow$ P(A) $\\leq$ P(B) P(B|A) \u0026gt; P(AB) AB $\\subseteq$ A $\\Longrightarrow$ P(AB) $\\leq$ P(A)","title":"总结-随机事件与概率"},{"content":"问题描述 因为工作需要，所以自己参考了 https://blog.csdn.net/u012111923/article/details/80705141#comments 大佬的教程，根据教程进行了一次测试。\n在其中，我发现断言无论如何都不会显示，如下图\n即使是在View Results Tree里全部通过如下图，断言也均不显示\n解决方法 是因为JMeter的机制，在断言成功的状态下并不会显示断言是否成功，仅会在断言失败的情况下才会显示错误信息。\n接下来，在Response Assertions的界面上，随便打一段匹配文本上去，让它进行匹配，如下图所示\n现在点击运行，我们再来看看断言结果\n这不就是我们期待已久的断言结果吗，哈哈\n","permalink":"https://ocsxxi.top/posts/2019-07-31-1/","summary":"问题描述 因为工作需要，所以自己参考了 https://blog.csdn.net/u012111923/article/details/80705141#comments 大佬的教程，根据教程进行了一次测试。\n在其中，我发现断言无论如何都不会显示，如下图\n即使是在View Results Tree里全部通过如下图，断言也均不显示\n解决方法 是因为JMeter的机制，在断言成功的状态下并不会显示断言是否成功，仅会在断言失败的情况下才会显示错误信息。\n接下来，在Response Assertions的界面上，随便打一段匹配文本上去，让它进行匹配，如下图所示\n现在点击运行，我们再来看看断言结果\n这不就是我们期待已久的断言结果吗，哈哈","title":"JMeter断言不提示错误信息"},{"content":"经过了两个小时的努力，终于把这个问题解决了，关于这个加载界面，真的是一把鼻涕一把泪，话不多说上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import android.app.Activity; import android.content.Intent; import android.os.Handler; import android.os.Message; import android.os.Bundle; import android.view.Window; import android.view.WindowManager; public class SplashActivity extends Activity { private Handler handler= new Handler() { @Override public void handleMessage(Message msg) { jumpToMainPage(); super.handleMessage(msg); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_splash); handler.sendEmptyMessageDelayed(0,4000); } public void jumpToMainPage(){ Intent intent = new Intent(SplashActivity.this, MainActivity.class); startActivity(intent); finish(); } } 在此我使用了Handler来进行页面的延迟自动加载\n需要注意的是requestWindowFeature()一定要在setContentView()之前被执行\n否则在虚拟机上运行会崩溃，emmmm至少我的是崩溃了\n从知道上面这条信息还是从logcat获取的，在这之前我并不重视logcat，所以调试的时候一定要注意logcat上的出错信息，对于程序开发会有很大的帮助\n还有一点要说的就是，我的splash界面 是由原来的main界面 改过来的，所以一定要记得在splash界面 中的顶层容器的\ntools:context=\u0026#34;\u0026#34; 属性中填写实际的类名以及类存在的路径，否则无法启动\n感谢您的阅读\n","permalink":"https://ocsxxi.top/posts/2019-04-24-1/","summary":"经过了两个小时的努力，终于把这个问题解决了，关于这个加载界面，真的是一把鼻涕一把泪，话不多说上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import android.app.Activity; import android.content.Intent; import android.os.Handler; import android.os.Message; import android.os.Bundle; import android.view.Window; import android.view.WindowManager; public class SplashActivity extends Activity { private Handler handler= new Handler() { @Override public void handleMessage(Message msg) { jumpToMainPage(); super.handleMessage(msg); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.","title":"Android splash界面 —— 加载界面"},{"content":"前提： 配置好了React Native并且按照官网的教程，生成了我的AwesomeProject，并且成功运行。\n复现 接下来按照官网教程生成 Hello World程序，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 import React, { Component } from \u0026#39;react\u0026#39;; import { Text, View } from \u0026#39;react-native\u0026#39;; export default class HelloWorldApp extends Component { render() { return ( \u0026lt;View style={{ flex: 1, justifyContent: \u0026#34;center\u0026#34;, alignItems: \u0026#34;center\u0026#34; }}\u0026gt; \u0026lt;Text\u0026gt;Hello, world!\u0026lt;/Text\u0026gt; \u0026lt;/View\u0026gt; ); } } 将上面的代码覆盖App.js后，在命令行中输入：\n1 react-native run-android 虚拟机反馈报错500，并在cmd中用红色的^指向return中第一个View的开始符号“\u0026lt;”\n解决 关闭含有server的窗口，重新输入命令：\n1 react-native start 然后将应用部署至虚拟机，输入命令：\n1 react-native run-android 虚拟机在屏幕中央显示了Hello World，成功运行，问题解决。\n","permalink":"https://ocsxxi.top/posts/2019-04-24-2/","summary":"前提： 配置好了React Native并且按照官网的教程，生成了我的AwesomeProject，并且成功运行。\n复现 接下来按照官网教程生成 Hello World程序，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 import React, { Component } from \u0026#39;react\u0026#39;; import { Text, View } from \u0026#39;react-native\u0026#39;; export default class HelloWorldApp extends Component { render() { return ( \u0026lt;View style={{ flex: 1, justifyContent: \u0026#34;center\u0026#34;, alignItems: \u0026#34;center\u0026#34; }}\u0026gt; \u0026lt;Text\u0026gt;Hello, world!\u0026lt;/Text\u0026gt; \u0026lt;/View\u0026gt; ); } } 将上面的代码覆盖App.js后，在命令行中输入：\n1 react-native run-android 虚拟机反馈报错500，并在cmd中用红色的^指向return中第一个View的开始符号“\u0026lt;”\n解决 关闭含有server的窗口，重新输入命令：\n1 react-native start 然后将应用部署至虚拟机，输入命令：","title":"React Native 500报错指向 '\u003c'"},{"content":"如图建立People类，并实例化一个对象p1, 报错如图\n我们来详细看一下如图报错：编译器告诉我们说 People类的构造函数不能接收参数\n解决办法：\n使用def init(self, …) ——\u0026gt;注意这里的下划线是两个下划线__，而不是单个下划线_\n而非def init(self, …)\n如图删除原来的People类\n如图重新构建People类，并实例化People类对象p1\n通过sayHello()函数来测试是否成功实例化对象, 输出了信息\n即构造类成功\n","permalink":"https://ocsxxi.top/posts/2019-04-14-2/","summary":"如图建立People类，并实例化一个对象p1, 报错如图\n我们来详细看一下如图报错：编译器告诉我们说 People类的构造函数不能接收参数\n解决办法：\n使用def init(self, …) ——\u0026gt;注意这里的下划线是两个下划线__，而不是单个下划线_\n而非def init(self, …)\n如图删除原来的People类\n如图重新构建People类，并实例化People类对象p1\n通过sayHello()函数来测试是否成功实例化对象, 输出了信息\n即构造类成功","title":"Python构造函数takes no arguments"},{"content":"原因是Hadoop2.0以后的版本采用的是 YARN 作为资源管理器，包含了1.x版本的JobTracker和TaskTracker功能，\n即 YARN 替代了单独存在的 JobTracker 与 TaskTracker。\n2.0之后的版本，安装配置成功后启动Hadoop后，通过jps命令将如图只显示以下几个进程\n参考：https://blog.csdn.net/ASN_forever/article/details/81062238\n","permalink":"https://ocsxxi.top/posts/2019-04-14-1/","summary":"原因是Hadoop2.0以后的版本采用的是 YARN 作为资源管理器，包含了1.x版本的JobTracker和TaskTracker功能，\n即 YARN 替代了单独存在的 JobTracker 与 TaskTracker。\n2.0之后的版本，安装配置成功后启动Hadoop后，通过jps命令将如图只显示以下几个进程\n参考：https://blog.csdn.net/ASN_forever/article/details/81062238","title":"Hadoop3.2.0 启动后通过jps命令找不到JobTracker和TaskTracker"},{"content":"因为要学习Hadoop的缘故，用VMware给自己装了个Ubuntu Server，版本是18.04.2-amd64\n因为之前使用的Ubuntu Desktop版本都是安装时候设置用户的时候，用户和超级用户是同一个密码，因为是学习用，也没有太在意这些，但是这次安装成功以后居然不能用用户的密码登录超级用户，也搜了一小段时间的解决办法。\n最终，给出如下解决方案：\n先使用安装时创建的用户登录进系统\n在控制台输入”sudo passwd”\n提示输入用户密码\n为root输入密码与确认密码\n成功后shell会提示”passwd: password updated successfully”，就可以使用密码登录超级用户了\n附上我自己成功为root用户添加密码的图片\n参考: https://www.cnblogs.com/yuejin/p/3645294.html\n","permalink":"https://ocsxxi.top/posts/2019-04-05-1/","summary":"因为要学习Hadoop的缘故，用VMware给自己装了个Ubuntu Server，版本是18.04.2-amd64\n因为之前使用的Ubuntu Desktop版本都是安装时候设置用户的时候，用户和超级用户是同一个密码，因为是学习用，也没有太在意这些，但是这次安装成功以后居然不能用用户的密码登录超级用户，也搜了一小段时间的解决办法。\n最终，给出如下解决方案：\n先使用安装时创建的用户登录进系统\n在控制台输入”sudo passwd”\n提示输入用户密码\n为root输入密码与确认密码\n成功后shell会提示”passwd: password updated successfully”，就可以使用密码登录超级用户了\n附上我自己成功为root用户添加密码的图片\n参考: https://www.cnblogs.com/yuejin/p/3645294.html","title":"Ubuntu Server安装后无法进入root超级用户解决办法"},{"content":"Git是一个简便的版本控制工具，初期使用一般是通过Git Bash来进行使用，以便于记住Git命令，后期一般通过Git GUI来进行使用，可以更加方便快捷地管理版本库。（ 版本库(repository)，也称仓库，是用于存储不同版本信息、以及文件的仓库）\nGit环境需要进行本地安装，官网https://git-scm.com/，通过自己的操作系统来选择合适的安装包进行下载安装并进行初始配置。\n如在windows系统下，想将桌面的test文件夹作为某次开发的仓库，可以双击打开test文件夹，在空白处右键选择“git bash here”\n即可打开bash命令行，然后直接在bash命令行中键入\n1 git init 如果反馈信息如下，并在下一行等待输入，即创建版本库成功\n1 Initialized empty Git repository in C:/Users/Admin/Desktop/test/.git/ 在test目录内创建rd.txt文本文件，并在其中写入”hello world”\n继续在git bash 命令行中键入命令\n1 git add rd.txt 这行命令的作用是将rd.txt作为预备提交文件进行添加\n如果如下显示，则添加成功\n接下来进行第一次提交，使用命令如下\n1 git commit -m \u0026#34;\u0026lt;提交说明\u0026gt;\u0026#34; \u0026lt;提交说明\u0026gt;可以更改为自己的说明，如果显示如下，则提交成功\n我们再将rd.txt进行一次修改，再进行第二次提交\n然后我们现在可以键入以下命令，来查看当前仓库的日志\n1 git log 如下所示\n在黄色的commit后面长长的一串码是对应版本的版本号\n我们现在假设产品经理告诉我们，第二次的修改是没有用的，那么我们就需要将版本回滚到第一版，也就是”my first commit”那一版，我们可以键入下面的命令\n1 git reset --hard HEAD^ 可以看到反馈了如下信息\n并且rd.txt和git log命令中，均只剩下第一次提交的内容，如下所示\n这样就说明了我们回滚操作成功了\n现在再假设产品经理告诉我们，他看错了，第二次修改的内容是需要的，那么这样我们就要退回回滚操作之前，只要当前bash命令行没有关闭，并且我们还能查到第二次的版本id，那么我们就能退回回滚操作之前，命令如下\n1 git reset --hard \u0026lt;版本号\u0026gt; \u0026lt;版本号\u0026gt;应该填写自己命令行中的第二次提交的版本id，如下\n看到这里，有很多小伙伴就会迷茫了，会问：刚才显示的第二次的版本id不是116b28f9460a5a0222ef0328c0c76e3c3fc95121吗？为什么我只写了一个116b2？\n这是因为git的控制机制来说，我们只要能够给bash一个可以辨识到独一无二的版本号的序列，那么它就可以自动为我们匹配到我们想要去使用的版本号。\n使用退回命令后，rd.txt内容显示如下，即表明我们的退回回滚操作之前的操作成功。\n感谢您的阅读\n","permalink":"https://ocsxxi.top/posts/2019-03-05-1/","summary":"Git是一个简便的版本控制工具，初期使用一般是通过Git Bash来进行使用，以便于记住Git命令，后期一般通过Git GUI来进行使用，可以更加方便快捷地管理版本库。（ 版本库(repository)，也称仓库，是用于存储不同版本信息、以及文件的仓库）\nGit环境需要进行本地安装，官网https://git-scm.com/，通过自己的操作系统来选择合适的安装包进行下载安装并进行初始配置。\n如在windows系统下，想将桌面的test文件夹作为某次开发的仓库，可以双击打开test文件夹，在空白处右键选择“git bash here”\n即可打开bash命令行，然后直接在bash命令行中键入\n1 git init 如果反馈信息如下，并在下一行等待输入，即创建版本库成功\n1 Initialized empty Git repository in C:/Users/Admin/Desktop/test/.git/ 在test目录内创建rd.txt文本文件，并在其中写入”hello world”\n继续在git bash 命令行中键入命令\n1 git add rd.txt 这行命令的作用是将rd.txt作为预备提交文件进行添加\n如果如下显示，则添加成功\n接下来进行第一次提交，使用命令如下\n1 git commit -m \u0026#34;\u0026lt;提交说明\u0026gt;\u0026#34; \u0026lt;提交说明\u0026gt;可以更改为自己的说明，如果显示如下，则提交成功\n我们再将rd.txt进行一次修改，再进行第二次提交\n然后我们现在可以键入以下命令，来查看当前仓库的日志\n1 git log 如下所示\n在黄色的commit后面长长的一串码是对应版本的版本号\n我们现在假设产品经理告诉我们，第二次的修改是没有用的，那么我们就需要将版本回滚到第一版，也就是”my first commit”那一版，我们可以键入下面的命令\n1 git reset --hard HEAD^ 可以看到反馈了如下信息\n并且rd.txt和git log命令中，均只剩下第一次提交的内容，如下所示\n这样就说明了我们回滚操作成功了\n现在再假设产品经理告诉我们，他看错了，第二次修改的内容是需要的，那么这样我们就要退回回滚操作之前，只要当前bash命令行没有关闭，并且我们还能查到第二次的版本id，那么我们就能退回回滚操作之前，命令如下\n1 git reset --hard \u0026lt;版本号\u0026gt; \u0026lt;版本号\u0026gt;应该填写自己命令行中的第二次提交的版本id，如下\n看到这里，有很多小伙伴就会迷茫了，会问：刚才显示的第二次的版本id不是116b28f9460a5a0222ef0328c0c76e3c3fc95121吗？为什么我只写了一个116b2？\n这是因为git的控制机制来说，我们只要能够给bash一个可以辨识到独一无二的版本号的序列，那么它就可以自动为我们匹配到我们想要去使用的版本号。\n使用退回命令后，rd.txt内容显示如下，即表明我们的退回回滚操作之前的操作成功。\n感谢您的阅读","title":"版本库——Git初探"},{"content":"在数据库的选择操作SELECT中经常会用到聚合条件，最常见也是最常用的是WHERE语句，故本文不会着重介绍WHERE语句。\n现假设在某数据库中有一个名为PRODUCT的表，表结构及内部数据如下\n1 2 3 4 5 CREATE TABLE PRODUCT( Pno CHAR(20) PRIMARY KEY, Pname CHAR(10), Pamount INT ); 1 2 3 4 5 6 7 8 9 +-----+-------+---------+ | Pno | Pname | Pamount | +-----+-------+---------+ | 001 | a | 1 | | 002 | a | 2 | | 003 | b | 1 | | 004 | b | 2 | | 005 | b | 6 | +-----+-------+---------+ ORDER BY 这一语句主要是显示排序用，如果选择了多条类似的记录，那么在查询语句中便可用到此语句，使用如下\nSELECT * FROM PRODUCT ORDER BY Pno ASC; 上面的语句根据Pno的值来对产品记录进行升序排列(仅当次查询有效)，即根据ORDER BY后跟的列名进行升序排列。\n1 2 3 4 5 6 7 8 9 10 11 mysql\u0026gt; SELECT * FROM PRODUCT ORDER BY Pno ASC; +-----+-------+---------+ | Pno | Pname | Pamount | +-----+-------+---------+ | 001 | a | 1 | | 002 | a | 2 | | 003 | b | 1 | | 004 | b | 2 | | 005 | b | 6 | +-----+-------+---------+ 5 rows in set (0.00 sec) 如果需要降序排列，只需把最后的ASC更换为DESC即可。\n1 2 3 4 5 6 7 8 9 10 11 mysql\u0026gt; SELECT * FROM PRODUCT ORDER BY Pno DESC; +-----+-------+---------+ | Pno | Pname | Pamount | +-----+-------+---------+ | 005 | b | 6 | | 004 | b | 2 | | 003 | b | 1 | | 002 | a | 2 | | 001 | a | 1 | +-----+-------+---------+ 5 rows in set (0.00 sec) § 当排序列含空值时,排序列为空值的原组最后显示。\nGROUP BY 这一语句主要是作分类汇总，如需要相同名称记录的合计库存量，在查询语句中可用到GROUP BY如下\nSELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname; 结果如下\n1 2 3 4 5 6 7 8 mysql\u0026gt; SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname; +-------+--------------+ | Pname | SUM(Pamount) | +-------+--------------+ | a | 3 | | b | 9 | +-------+--------------+ 2 rows in set (0.00 sec) HAVING HAVING可以作为WHERE的拓展，因为在WHERE中不可用到聚合函数，而在HAVING中可以使用聚合函数。\n如需了解总量大于5的相同名称记录的合计库存量，则可用到HAVING使用如下\n1 SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname HAVING SUM(Pamount)\u0026gt;5; 结果如下\n1 2 3 4 5 6 7 mysql\u0026gt; SELECT Pname,SUM(Pamount) FROM PRODUCT GROUP BY Pname HAVING SUM(Pamount)\u0026gt;5; +-------+--------------+ | Pname | SUM(Pamount) | +-------+--------------+ | b | 9 | +-------+--------------+ 1 row in set (0.00 sec) HAVING与WHERE作用的对象不同。WHERE子句作用于表和视图，HAVING子句作用于组。 WHERE在分组和聚合运算之前选取输入行（因此，它控制进入聚合运算的记录），而HAVING在分组和聚合之后选取分组的行。因此，WHERE子句不能包含聚合函数；因为试图用聚合函数判断那些行输入做聚合运算是没有意义的。 相反，HAVING子句总是包含聚合函数。\n以上纯属个人对于选择操作中的ORDER BY、GROUP BY以及HAVING的看法及见解，如有误，感谢各位的指证\n","permalink":"https://ocsxxi.top/posts/2018-12-20-2/","summary":"在数据库的选择操作SELECT中经常会用到聚合条件，最常见也是最常用的是WHERE语句，故本文不会着重介绍WHERE语句。\n现假设在某数据库中有一个名为PRODUCT的表，表结构及内部数据如下\n1 2 3 4 5 CREATE TABLE PRODUCT( Pno CHAR(20) PRIMARY KEY, Pname CHAR(10), Pamount INT ); 1 2 3 4 5 6 7 8 9 +-----+-------+---------+ | Pno | Pname | Pamount | +-----+-------+---------+ | 001 | a | 1 | | 002 | a | 2 | | 003 | b | 1 | | 004 | b | 2 | | 005 | b | 6 | +-----+-------+---------+ ORDER BY 这一语句主要是显示排序用，如果选择了多条类似的记录，那么在查询语句中便可用到此语句，使用如下","title":"数据库中的GROUP BY与ORDER BY、WHERE与HAVING"},{"content":"欢迎大家来到我的个人博客\n","permalink":"https://ocsxxi.top/posts/2018-12-20-1/","summary":"欢迎大家来到我的个人博客","title":"Hello World"}]